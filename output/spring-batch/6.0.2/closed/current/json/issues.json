[
  {
    "number": 5181,
    "title": "MetaDataInstanceFactory default values cause StepContext collision in StepScopeTestUtils when @SpringBatchTest is active",
    "state": "closed",
    "created_at": "2025-12-23T07:20:59Z",
    "updated_at": "2026-01-21T05:09:13Z",
    "author": "KILL9-NO-MERCY",
    "url": "https://github.com/spring-projects/spring-batch/issues/5181",
    "body": "## Bug description: \nThere is a logical collision in StepSynchronizationManager when using StepScopeTestUtils in a test environment managed by @SpringBatchTest.\n\nStepExecution determines equality based on stepName, jobExecutionId, and id. Since MetaDataInstanceFactory provides static default values for all these fields, multiple instances created by the factory are treated as identical keys in the SynchronizationManagerSupport.contexts map.\n\nThis prevents StepScopeTestUtils from registering a new context with custom JobParameters, as the computeIfAbsent logic finds the existing context registered by StepScopeTestExecutionListener (which is part of @SpringBatchTest).\n\n## Steps to reproduce:\nAnnotate a test class with @SpringBatchTest.\n\nInside a test method, use StepScopeTestUtils.doInStepScope() with a StepExecution created via MetaDataInstanceFactory.createStepExecution(jobParameters).\n\nThe Tasklet or ItemStream inside the scope will fail to see the jobParameters because it is bound to the listener's initial context.\n\n## Failing Example: \nexample job\n```java\n@Slf4j\n@Configuration\npublic class IssueReproductionJobConfiguration {\n    @Bean\n    public Job issueReproductionJob(JobRepository jobRepository, Step issueReproductionStep) {\n        return new JobBuilder(jobRepository)\n                .incrementer(new RunIdIncrementer())\n                .start(issueReproductionStep)\n                .build();\n    }\n\n    @Bean\n    public Step issueReproductionStep(\n            JobRepository jobRepository,\n            Tasklet issueReproductionTasklet\n    ) {\n        return new StepBuilder(jobRepository)\n                .tasklet(issueReproductionTasklet)\n                .build();\n    }\n\n    @Bean\n    @StepScope\n    public Tasklet issueReproductionTasklet(@Value(\"#{jobParameters['testParam']}\") String testParam) {\n        return (contribution, chunkContext) -> {\n            contribution.getStepExecution().getExecutionContext().putString(\"result\", testParam);\n            return RepeatStatus.FINISHED;\n        };\n    }\n}\n```\n\ntest class\n```java\n@SpringBatchTest\n@SpringBootTest\n@ActiveProfiles(\"test\")\n@Import(TestBatchConfiguration.class)\npublic class IssueReproductionTest {\n    @Autowired\n    private Tasklet issueReproductionTasklet;\n\n    public StepExecution getStepExecution() throws IOException {\n        return MetaDataInstanceFactory.createStepExecution(\"dummy\", -1L);\n    }\n\n    @Test\n    @DisplayName(\"MetadataInstanceFactory ID collision causes JobParameter injection failure\")\n    void reproduceIdCollisionBug() throws Exception {\n        // Given\n        String expectedValue = \"HelloBatch\";\n        JobParameters jobParameters = new JobParametersBuilder()\n                .addString(\"testParam\", expectedValue)\n                .toJobParameters();\n\n        // MetadataInstanceFactory in 6.x / maybe after 5.2.3?? creates StepExecution with fixed ID 1234L\n        StepExecution stepExecution = MetaDataInstanceFactory.createStepExecution(jobParameters);\n\n        // When\n        StepScopeTestUtils.doInStepScope(stepExecution, () ->\n                Objects.requireNonNull(issueReproductionTasklet.execute(stepExecution.createStepContribution(), null))\n        );\n\n        // Then\n        String actualValue = stepExecution.getExecutionContext().getString(\"result\");\n\n        // This will FAIL because 'actualValue' will be null.\n        // The Tasklet retrieved the listener's context (which has no JobParameters)\n        // instead of the one passed via StepScopeTestUtils due to ID collision (1234L).\n        assertEquals(expectedValue, actualValue);\n    }\n}\n\n@TestConfiguration\npublic class TestBatchConfiguration extends DefaultBatchConfiguration {\n}\n```\n\napplication-test.yml\n```yaml\nspring:\n  batch:\n    job:\n      enabled: false\n```\ntest result:\n```bash\nValue for key=[result] is not of type: [class java.lang.String], it is [null]\njava.lang.ClassCastException: Value for key=[result] is not of type: [class java.lang.String], it is [null]\n```\n\n## Expected behavior:\nThe StepExecution and its corresponding StepContext created within StepScopeTestUtils.doInStepScope() should be correctly registered and accessible through the StepSynchronizationManager, even when @SpringBatchTest is active.\n\n(Note: Deciding on the best fix seems non-trivial to me, as it could involve changing the ID generation strategy in MetaDataInstanceFactory or adjusting how StepSynchronizationManager handles overlapping registrations in a test environment.)\nWorkaround: Users must manually provide a unique name or ID to bypass the equals/hashCode collision:\n\n## Workaround: \nTo bypass the current collision, users can explicitly define a getStepExecution() method within their test class. By returning a StepExecution with a unique name or a different ID (e.g., -1L), you can prevent the StepScopeTestExecutionListener from occupying the default ID (1234L), thus allowing StepScopeTestUtils to work as intended:\n\n```java\n/**\n * Workaround: Define getStepExecution() in the test class to avoid ID collision.\n * By providing a non-default ID or name, we ensure that the listener-registered \n * context does not conflict with the one created in StepScopeTestUtils.\n */\npublic StepExecution getStepExecution() {\n    return MetaDataInstanceFactory.createStepExecution(\"uniqueStep\", -1L);\n}\n```\n\ntest result:\n```bash\n> Task :test\nBUILD SUCCESSFUL in 3s\n```\n\nThanks for your time and for maintaining this great project!",
    "labels": [
      "in: test",
      "type: bug"
    ],
    "comments": [
      {
        "author": "injae-kim",
        "created_at": "2026-01-11T11:25:50Z",
        "body": "FYI) Fix PR: https://github.com/spring-projects/spring-batch/pull/5208 ðŸ‘"
      },
      {
        "author": "fmbenhassine",
        "created_at": "2026-01-13T10:21:04Z",
        "body": "I am trying to reproduce this issue but I am not able to. The test you shared uses Spring Boot, but I want to make sure this is a valid issue by only using Spring Batch first.\n\nAt 9ae777572a0978572e25f04d4cb93c0ad02b9a0f, when I add the following classes (the same you shared but without Spring Boot) in the `org.springframework.batch.test` package, the test you mentioned passes:\n\n```java\npackage org.springframework.batch.test;\n\nimport org.springframework.batch.core.configuration.annotation.EnableBatchProcessing;\nimport org.springframework.batch.core.configuration.annotation.StepScope;\nimport org.springframework.batch.core.job.Job;\nimport org.springframework.batch.core.job.builder.JobBuilder;\nimport org.springframework.batch.core.job.parameters.RunIdIncrementer;\nimport org.springframework.batch.core.repository.JobRepository;\nimport org.springframework.batch.core.step.Step;\nimport org.springframework.batch.core.step.builder.StepBuilder;\nimport org.springframework.batch.core.step.tasklet.Tasklet;\nimport org.springframework.batch.infrastructure.repeat.RepeatStatus;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\n@EnableBatchProcessing\npublic class IssueReproductionJobConfiguration {\n\n    @Bean\n    public Job issueReproductionJob(JobRepository jobRepository, Step issueReproductionStep) {\n        return new JobBuilder(jobRepository)\n                .incrementer(new RunIdIncrementer())\n                .start(issueReproductionStep)\n                .build();\n    }\n\n    @Bean\n    public Step issueReproductionStep(\n            JobRepository jobRepository,\n            Tasklet issueReproductionTasklet\n    ) {\n        return new StepBuilder(jobRepository)\n                .tasklet(issueReproductionTasklet)\n                .build();\n    }\n\n    @Bean\n    @StepScope\n    public Tasklet issueReproductionTasklet(@Value(\"#{jobParameters['testParam']}\") String testParam) {\n        return (contribution, chunkContext) -> {\n            contribution.getStepExecution().getExecutionContext().putString(\"result\", testParam);\n            return RepeatStatus.FINISHED;\n        };\n    }\n}\n```\n\n```java\npackage org.springframework.batch.test;\n\nimport java.io.IOException;\nimport java.util.Objects;\n\nimport org.junit.jupiter.api.DisplayName;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.extension.ExtendWith;\n\nimport org.springframework.batch.core.job.parameters.JobParameters;\nimport org.springframework.batch.core.job.parameters.JobParametersBuilder;\nimport org.springframework.batch.core.step.StepExecution;\nimport org.springframework.batch.core.step.tasklet.Tasklet;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.test.context.ContextConfiguration;\nimport org.springframework.test.context.junit.jupiter.SpringExtension;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\n@ContextConfiguration(classes = IssueReproductionJobConfiguration.class)\n@ExtendWith(SpringExtension.class)\npublic class IssueReproductionTest {\n\n    @Autowired\n    private Tasklet issueReproductionTasklet;\n\n    public StepExecution getStepExecution() throws IOException {\n        return MetaDataInstanceFactory.createStepExecution(\"dummy\", -1L);\n    }\n\n    @Test\n    @DisplayName(\"MetadataInstanceFactory ID collision causes JobParameter injection failure\")\n    void reproduceIdCollisionBug() throws Exception {\n        // Given\n        String expectedValue = \"HelloBatch\";\n        JobParameters jobParameters = new JobParametersBuilder()\n                .addString(\"testParam\", expectedValue)\n                .toJobParameters();\n\n        // MetadataInstanceFactory in 6.x / maybe after 5.2.3?? creates StepExecution with fixed ID 1234L\n        StepExecution stepExecution = MetaDataInstanceFactory.createStepExecution(jobParameters);\n\n        // When\n        StepScopeTestUtils.doInStepScope(stepExecution, () ->\n                Objects.requireNonNull(issueReproductionTasklet.execute(stepExecution.createStepContribution(), null))\n        );\n\n        // Then\n        String actualValue = stepExecution.getExecutionContext().getString(\"result\");\n\n        // This will FAIL because 'actualValue' will be null.\n        // The Tasklet retrieved the listener's context (which has no JobParameters)\n        // instead of the one passed via StepScopeTestUtils due to ID collision (1234L).\n        assertEquals(expectedValue, actualValue);\n    }\n}\n```\n\nCan you please check?"
      },
      {
        "author": "KILL9-NO-MERCY",
        "created_at": "2026-01-15T05:40:00Z",
        "body": "Hi @fmbenhassine \nThank you for taking the time to investigate this issue!\n\nI apologize for the confusion in my initial report. It appears you tested with the workaround applied, which is why the test passed in your environment.\n\n### The Issue\nThe code you tested includes a getStepExecution() method that uses -1L as the ID:\n```java\npublic StepExecution getStepExecution() throws IOException {\n    return MetaDataInstanceFactory.createStepExecution(\"dummy\", -1L);\n}\n```\nThis is actually the workaround I mentioned to avoid the ID collision. When using -1L, the listener-registered context (ID: 1234L) and the test-created context (ID: -1L) don't collide, so the test works correctly.\n\n#### To Reproduce the Bug\nTo reproduce the actual bug, you need to either:\n\nRemove the getStepExecution() method entirely, OR\nUse the default ID (1234L) instead of -1L\n\nHere's a test case that clearly demonstrates the ID collision:\n```java\n@SpringBatchTest\n@ContextConfiguration(classes = IssueReproductionJobConfiguration.class)\n@ExtendWith(SpringExtension.class)\npublic class IssueReproductionTest {\n\n    @Autowired\n    private Tasklet issueReproductionTasklet;\n\n    public StepExecution getStepExecution() throws IOException {\n        String expectedValue = \"HelloBatch2\";\n        JobParameters jobParameters = new JobParametersBuilder()\n            .addString(\"testParam\", expectedValue)\n            .toJobParameters();\n\n        return MetaDataInstanceFactory.createStepExecution(jobParameters);\n    }\n\n    @Test\n    void reproduceIdCollisionBug() throws Exception {\n        String expectedValue = \"HelloBatch1\";\n        JobParameters jobParameters = new JobParametersBuilder()\n            .addString(\"testParam\", expectedValue)\n            .toJobParameters();\n\n        StepExecution stepExecution = MetaDataInstanceFactory.createStepExecution(jobParameters);\n\n        StepScopeTestUtils.doInStepScope(stepExecution,\n            () -> issueReproductionTasklet.execute(stepExecution.createStepContribution(), null));\n\n        String actualValue = stepExecution.getExecutionContext().getString(\"result\");\n        // This assertion will PASS, but it proves the bug!\n        // The tasklet receives \"HelloBatch2\" (from listener's context)\n        // instead of \"HelloBatch1\" (from the test's StepExecution)\n        assertEquals(\"HelloBatch2\", actualValue);\n    }\n}\n```\nIn this test:\nThe listener creates a StepExecution with testParam=\"HelloBatch2\" (ID: 1234L)\nThe test tries to create a StepExecution with testParam=\"HelloBatch1\" (ID: 1234L)\nDue to ID collision, the listener's context is used, so the tasklet receives \"HelloBatch2\" instead of \"HelloBatch1\"\nThe test passes with assertEquals(\"HelloBatch2\", actualValue), but this proves the wrong context is being used!\n\n#### Root Cause\nBoth StepScopeTestExecutionListener (activated by @SpringBatchTest) and MetaDataInstanceFactory.createStepExecution(jobParameters) use the same default ID (1234L). Since StepExecution.equals() only compares IDs, StepSynchronizationManager treats them as the same key, causing a context collision.\n\n#### Reproduction Confirmed\nI've successfully reproduced this bug in the Spring Batch codebase:\nEnvironment: Spring Batch 6.0.1-SNAPSHOT (commit 9ae7775), JDK 22\n\nPlease let me know if you need any additional information or clarification."
      },
      {
        "author": "fmbenhassine",
        "created_at": "2026-01-21T05:00:56Z",
        "body": "Thank you for the detailed feedback! I see now, apologies for misunderstanding your initial description.\n\n#5208 LGTM, so I will plan the fix for the upcoming 6.0.2."
      }
    ],
    "closing_references": {
      "pull_requests": [],
      "commits": [
        "4f8609bf5c7e65a7cb4eccf70730b8c33072d185"
      ]
    }
  }
]