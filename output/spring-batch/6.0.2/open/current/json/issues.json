[
  {
    "number": 5227,
    "title": "Compatibility issues between v5 and v6 when Migrating from `CommandLineJobRunner` to `CommandLineJobOperator`",
    "state": "open",
    "created_at": "2026-01-21T09:34:16Z",
    "updated_at": "2026-01-21T09:35:19Z",
    "author": "fmbenhassine",
    "url": "https://github.com/spring-projects/spring-batch/issues/5227",
    "body": "\n### Discussed in https://github.com/spring-projects/spring-batch/discussions/5213\n\n<div type='discussions-op-text'>\n\n<sup>Originally posted by **takahashihrzg** November 21, 2025</sup>\nStarting with Spring Batch 6.0.0-M1, `CommandLineJobRunner` was deprecated and `CommandLineJobOperator` was introduced.\nWe are planning to migrate from `CommandLineJobRunner` to `CommandLineJobOperator`.\n\nHowever, We found several incompatibilities during migration and are not sure how to handle them.\nCould you please explain the reasons for these incompatible changes and how we should migrate?\n\n1. Error output destination differs when starting a job without required arguments.\n2. Validation exceptions at job startup are not logged.\n3. We cannot customize `ExitCodeMapper` or `JobParametersConverter`.\n4. The parameters required to stop or restart a job are different.\n\n---\n\n## 1) Error output destination differs when starting a job without required arguments\n\nWith `CommandLineJobRunner`, if we started a job without arguments such as `jobPath` or `jobIdentifier`, the exception was written to the **log**.\n\nWith `CommandLineJobOperator`, if we start a job without arguments such as `jobPath` or `jobIdentifier`, all exceptions are caught inside `CommandLineJobOperator` and printed only to the console via `System.err.printf`.\n\nWhy was this changed from logging exceptions (in `CommandLineJobRunner`) to printing them to standard error (in `CommandLineJobOperator`)? From an operations/monitoring point of view, exceptions are generally expected to be recorded in logs.\n\n**Request:** printing exceptions only to standard error adds complexity to monitoring. Could you also log these exceptions?\n\n---\n\n## 2) Validation exceptions at job startup are not logged\n\nWith `CommandLineJobRunner`, if validation failed at job startup, the exception was thrown as-is and also logged.\n\nWith `CommandLineJobOperator`, if validation fails at startup, the exception is caught inside the `start` method and an exit code of 1 is returned.\n\nAs a result, when validation fails at startup with `CommandLineJobOperator`, the exception is neither stored in the `batch_job_execution` table nor written to the log.  \nHow can we verify that startup validation is actually running?\n\n**Request:** please record validation failures in the logs.\n\n**Example:**\n\nJob definition\n```java\n@Bean\npublic Job testJob(JobRepository jobRepository,\n                                    Step step01) {\n    return new JobBuilder(\"testJob\",\n            jobRepository)\n            .start(step01)\n            .validator(new TestValidator())\n            .build();\n}\n```\n\n`TestValidator` code\n```java\nimport org.springframework.batch.core.job.parameters.JobParameter;\nimport org.springframework.batch.core.job.parameters.JobParameters;\nimport org.springframework.batch.core.job.parameters.JobParametersInvalidException;\nimport org.springframework.batch.core.job.parameters.JobParametersValidator;\n\nimport java.util.Map;\n\npublic class TestValidator implements JobParametersValidator {\n    @Override\n    public void validate(JobParameters parameters) throws JobParametersInvalidException {\n        Map<String, JobParameter<?>> params = parameters.getParameters();\n\n        String str = params.get(\"str\").getValue().toString();\n        int num = Integer.parseInt(params.get(\"num\").getValue().toString());\n\n        if (str.length() > num) {\n            throw new JobParametersInvalidException(\"The str must be less than or equal to num. [str:\" + str + \"][num:\" + num + \"]\");\n        }\n    }\n}\n```\n\nRun with the following parameters:\n```\n$ java CommandLineJobOperator TestJobConfig start testJob str=Hello num=4\n```\n\nWe expect an exception from `TestValidator` to appear in the log (this is what `CommandLineJobRunner` does), e.g.:\n```\n[2025/11/05 10:33:21] [main] [o.h.v.i.util.Version  ] [INFO ] HV000001: Hibernate Validator 9.0.1.Final\n[2025/11/05 10:33:21] [main] [o.s.b.c.l.s.CommandLineJobRunner] [ERROR] Job Terminated in error: The str must be less than or equal to num. [str:Hello][num:4]\norg.springframework.batch.core.JobParametersInvalidException: The str must be less than or equal to num. [str:Hello][num:4]\n```\n\nBut with `CommandLineJobOperator`, the exception from `TestValidator` is not shown, so we cannot confirm validation is working:\n```\n[2025/11/05 10:45:55] [main] [o.h.v.i.util.Version  ] [INFO ] HV000001: Hibernate Validator 9.0.1.Final\n[2025/11/05 10:45:55] [main] [o.s.b.c.l.s.CommandLineJobOperator] [INFO ] Starting job with name 'job01' and parameters: {str=Hello, num=4}\n```\n\n---\n\n## 3) Unable to customize `ExitCodeMapper` or `JobParametersConverter`\n\nWith `CommandLineJobRunner`, we could customize behavior by defining beans like `ExitCodeMapper` and `JobParametersConverter`, for example:\n\n```java\n@Bean\npublic ExitCodeMapper exitCodeMapper() {\n    final SimpleJvmExitCodeMapper simpleJvmExitCodeMapper = new SimpleJvmExitCodeMapper();\n    final Map<String, Integer> exitCodeMapper = new HashMap<>();\n    exitCodeMapper.put(\"NOOP\", 0);\n    exitCodeMapper.put(\"COMPLETED\", 0);\n    exitCodeMapper.put(\"STOPPED\", 255);\n    exitCodeMapper.put(\"FAILED\", 255);\n    exitCodeMapper.put(\"UNKNOWN\", 255);\n    exitCodeMapper.put(\"COMPLETED_CUSTOM\", 200);\n    exitCodeMapper.put(\"STOPPED_CUSTOM\", 201);\n    exitCodeMapper.put(\"FAILED_CUSTOM\", 202);\n    simpleJvmExitCodeMapper.setMapping(exitCodeMapper);\n    return simpleJvmExitCodeMapper;\n}\n\n@Bean\npublic JobParametersConverter jobParametersConverter(\n        @Qualifier(\"adminDataSource\") DataSource adminDataSource) {\n    return new JobParametersConverterImpl(adminDataSource);\n}\n```\n\nWith `CommandLineJobOperator`, even if we define such beans, behavior does not change.\n\nWe believe this is due to implementation differences between `CommandLineJobRunner#start` and `CommandLineJobOperator#main`.  \n`CommandLineJobRunner` uses `ApplicationContext.getAutowireCapableBeanFactory().autowireBeanProperties`, but `CommandLineJobOperator` only gets three beans (`JobOperator`, `JobRepository`, `JobRegistry`) from the DI container.\n\nBecause of this, even if `ExitCodeMapper` or `JobParametersConverter` exist as beans, they appear to be ignored by `CommandLineJobOperator`.\n\nCode excerpts:\n\n```java\n// CommandLineJobRunner#start\nint start(String jobPath, String jobIdentifier, String[] parameters, Set<String> opts) {\n\n    ConfigurableApplicationContext context = null;\n    // omitted\n        try {\n            context = new AnnotationConfigApplicationContext(Class.forName(jobPath));\n        }\n    // omitted\n        context.getAutowireCapableBeanFactory()\n            .autowireBeanProperties(this, AutowireCapableBeanFactory.AUTOWIRE_BY_TYPE, false);\n    // omitted\n}\n```\n\n```java\n// CommandLineJobOperator#main\npublic static void main(String[] args) {\n    // omitted\n    ConfigurableApplicationContext context = null;\n    try {\n        Class<?> jobConfigurationClass = Class.forName(jobConfigurationClassName);\n        context = new AnnotationConfigApplicationContext(jobConfigurationClass);\n    }\n    // omitted\n    try {\n        jobOperator = context.getBean(JobOperator.class);\n        jobRepository = context.getBean(JobRepository.class);\n        jobRegistry = context.getBean(JobRegistry.class);\n    }\n    // omitted\n    CommandLineJobOperator operator = new CommandLineJobOperator(jobOperator, jobRepository, jobRegistry);\n    // omitted\n}\n```\n\nWere these implementation changes intentional? If so, what was the reasoning?\n\n**Request:** please allow customization of `ExitCodeMapper` and `JobParametersConverter` with `CommandLineJobOperator` as well.\n\n---\n\n## 4) Different parameters needed to stop or restart a job\n\nWith `CommandLineJobRunner`, we could stop or restart a job by specifying either `jobName` or `jobExecutionId`.\n\nWith `CommandLineJobOperator`, we can only stop or restart by specifying `jobExecutionId`.\n\nIn practice, the user running the job typically only knows the `jobName` they provided.\n\nIf we need to stop or restart a job with `CommandLineJobOperator`, we first have to obtain the `jobExecutionId` somehow.\nWhat is the recommended way to get `jobExecutionId` from the command line?\n\n**Request:** please support stopping and restarting by `jobName` with `CommandLineJobOperator` as well.\n</div>",
    "labels": [
      "type: bug",
      "in: core",
      "status: for-internal-team"
    ],
    "comments": [
      {
        "author": "fmbenhassine",
        "created_at": "2026-01-21T09:34:59Z",
        "body": "Thank you for reporting this!\n\n> 1) Error output destination differs when starting a job without required arguments\n> Request: printing exceptions only to standard error adds complexity to monitoring. Could you also log these exceptions?\n\nThat's an oversight, I will fix it.\n\n> 2) Validation exceptions at job startup are not logged\n> Request: please record validation failures in the logs.\n\nSame here. I will update the new operator accordingly.\n\n> 3) Unable to customize ExitCodeMapper or JobParametersConverter\n> Were these implementation changes intentional? If so, what was the reasoning?\n\nYes it was intentional and the reason is the following: for this to work:\n\n```\ncontext.getAutowireCapableBeanFactory().autowireBeanProperties(this, AutowireCapableBeanFactory.AUTOWIRE_BY_TYPE, false);\n```\n\nthe command line job runner has to be defined as a bean in an application context. But what if I want to use it outside an application context? This is just impossible, note the `this` reference in the first argument to `autowireBeanProperties`. The new runner does not suffer from this limitation (and other limitations as explained in #4899). That said, we need to check (in the `main` method when we instantiate the operator) for the presence of any custom `ExitCodeMapper` or `JobParametersConverter` in the application context and set them on the operator.\n\nI will plan that for the next release and update the migration guide accordingly.\n\n> 4) Different parameters needed to stop or restart a job\n\nStopping or restarting a job by name was confusing. What if the job has two (or more) different instances running in parallel and you want to stop only one of them? Similarly, what if the job has two failed job instances and you only want to restart a single one? By specifying the execution you want to restart, this ambiguity is not possible. Getting the id of the failed execution is possible with a the `JobRepository` API. That said, you can still restart a job by name by using `JobRepository#getLastJobInstance(jobName)` and restarting the failed execution."
      }
    ],
    "closing_references": {
      "pull_requests": [],
      "commits": []
    }
  }
]