[
  {
    "number": 5176,
    "title": "ClosedChannelException and FileChannel leak when switching resources multiple times within the same transaction",
    "state": "closed",
    "created_at": "2025-12-20T13:23:46Z",
    "updated_at": "2026-01-21T08:09:56Z",
    "author": "banseok1216",
    "url": "https://github.com/spring-projects/spring-batch/issues/5176",
    "body": "## Bug description\n\nWhen `StaxEventItemWriter` is used **within the same transaction (TransactionTemplate)** in the following pattern, problems occur:\n\n- Using the same `StaxEventItemWriter` instance\n- `setResource(r1) -> open -> write -> close`\n- `setResource(r2) -> open -> write -> close`\n- `setResource(r3) -> open -> write -> close`\n\nObserved problems (depending on the environment, one or both may occur):\n\n1) `java.nio.channels.ClosedChannelException` at transaction commit (or at the end of transaction synchronization)  \n2) Some `FileChannel`s opened for r1/r2/r3 remain open after the transaction ends (resource leak)\n\nRelated issue:\n- https://github.com/spring-projects/spring-batch/issues/5098\n\n## Environment\n\n- Spring Batch version: 6.0.x, 5.2.x\n\n## Steps to reproduce\n\n1. Add the following two tests to Spring Batch codebase in `org.springframework.batch.infrastructure.item.xml.TransactionalStaxEventItemWriterTests`.\n2. Run tests. You will observe either:\n   - `ClosedChannelException` in `shouldWriteThreeSeparateFilesWhenMultipleOpenCloseAndResourceSwitchInSingleTransaction`, or\n   - a failure in `shouldCloseAllFileChannelsAfterTransaction` because some channels remain `isOpen() == true` after transaction completion.\n\n## Expected behavior\n\nEven when switching resources and opening/closing the writer multiple times within the same transaction:\n\n1) No `ClosedChannelException` should be thrown at transaction completion.  \n2) After the transaction ends (commit/rollback), **all FileChannels opened during that transaction must be closed**.\n\n## Minimal Complete Reproducible example\n\nThe following tests validate two aspects:\n\n1) Exception reproduction: `shouldWriteThreeSeparateFilesWhenMultipleOpenCloseAndResourceSwitchInSingleTransaction`  \n2) Leak reproduction: `shouldCloseAllFileChannelsAfterTransaction`  \n   - It uses reflection to extract the underlying `FileChannel` and checks `isOpen()` after the transaction.\n\n```java\n@Test\nvoid shouldWriteThreeSeparateFilesWhenMultipleOpenCloseAndResourceSwitchInSingleTransaction() throws Exception {\n    WritableResource r1 = new FileSystemResource(File.createTempFile(\"stax-tx-rot-1\", \".xml\"));\n    WritableResource r2 = new FileSystemResource(File.createTempFile(\"stax-tx-rot-2\", \".xml\"));\n    WritableResource r3 = new FileSystemResource(File.createTempFile(\"stax-tx-rot-3\", \".xml\"));\n\n    assertDoesNotThrow(() ->\n        new TransactionTemplate(transactionManager).execute((TransactionCallback<Void>) status -> {\n            try {\n                writer.setResource(r1);\n                writer.open(new ExecutionContext());\n                writer.write(items);\n                writer.close();\n\n                writer.setResource(r2);\n                writer.open(new ExecutionContext());\n                writer.write(items);\n                writer.close();\n\n                writer.setResource(r3);\n                writer.open(new ExecutionContext());\n                writer.write(items);\n                writer.close();\n\n                return null;\n            }\n            catch (Exception e) {\n                throw new RuntimeException(e);\n            }\n        })\n    );\n}\n\n@Test\nvoid shouldCloseAllFileChannelsAfterTransaction() throws Exception {\n    WritableResource r1 = new FileSystemResource(File.createTempFile(\"stax-tx-leak-1\", \".xml\"));\n    WritableResource r2 = new FileSystemResource(File.createTempFile(\"stax-tx-leak-2\", \".xml\"));\n    WritableResource r3 = new FileSystemResource(File.createTempFile(\"stax-tx-leak-3\", \".xml\"));\n\n    List<FileChannel> opened = new ArrayList<>();\n\n    try {\n        new TransactionTemplate(transactionManager).execute((TransactionCallback<Void>) status -> {\n            try {\n                writer.setResource(r1);\n                writer.open(new ExecutionContext());\n                FileChannel ch1 = extractChannelFromStaxWriter(writer);\n                assertNotNull(ch1);\n                opened.add(ch1);\n                writer.write(items);\n                writer.close();\n\n                writer.setResource(r2);\n                writer.open(new ExecutionContext());\n                FileChannel ch2 = extractChannelFromStaxWriter(writer);\n                assertNotNull(ch2);\n                opened.add(ch2);\n                writer.write(items);\n                writer.close();\n\n                writer.setResource(r3);\n                writer.open(new ExecutionContext());\n                FileChannel ch3 = extractChannelFromStaxWriter(writer);\n                assertNotNull(ch3);\n                opened.add(ch3);\n                writer.write(items);\n                writer.close();\n\n                return null;\n            }\n            catch (Exception ignored) {\n            }\n        });\n    }\n    catch (Exception ignored) {\n        // Continue to check leaks even if an exception happens\n    }\n\n    assertEquals(3, opened.size(), \"Expected 3 opened channels\");\n    for (FileChannel ch : opened) {\n        assertFalse(ch.isOpen(), \"FileChannel should be closed after transaction\");\n    }\n}\n\nprivate static FileChannel extractChannelFromStaxWriter(StaxEventItemWriter<?> w) throws Exception {\n    // legacy version\n    Field field = StaxEventItemWriter.class.getDeclaredField(\"channel\");\n    field.setAccessible(true);\n    return (FileChannel) field.get(w);\n    \n    // enhance version\n    Spring Batch 6.x layout: StaxEventItemWriter.state.channel\n    Field stateField = StaxEventItemWriter.class.getDeclaredField(\"state\");\n    stateField.setAccessible(true);\n    Object state = stateField.get(w);\n    Field channelField = state.getClass().getDeclaredField(\"channel\");\n    channelField.setAccessible(true);\n    return (FileChannel) channelField.get(state);\n}\n```\n\n## Observed stacktrace example\n\n```text\norg.springframework.batch.infrastructure.support.transaction.FlushFailedException: Could not write to output buffer\nCaused by: java.nio.channels.ClosedChannelException\n```\n\n## Why this happens\n\nThe key is that `TransactionAwareBufferedWriter` performs **flush/close at transaction synchronization time**.\n\nProblematic structure:\n\n- It registers a close callback like `TransactionAwareBufferedWriter(fileChannel, this::closeStream)`\n- But `closeStream()` closes the writer instanceâ€™s mutable field (e.g. `channel`) rather than closing the *specific* `fileChannel` that was used when the callback was registered\n- Within the same transaction, repeated `open()` calls overwrite the `channel` field as resources are switched\n- At transaction completion, the callback may:\n  - close only the last channel (leaving earlier channels open), and/or\n  - attempt to flush/write using a channel that is already closed, causing `ClosedChannelException`\n\n## Suggested fix direction\n\nTo make this safe, the resources created by **a single open()** (e.g. `FileOutputStream`/`FileChannel`/`Writer`/`XMLEventWriter`) should be **encapsulated in a state object**, and the `TransactionAwareBufferedWriter` close callback should be bound to **that specific state instance**.\n\nIn short:\n\n- Introduce an `OutputState` in `StaxEventItemWriter` to own those resources\n- Register the transactional close callback as `TransactionAwareBufferedWriter(fileChannel, state::closeStream)`\n- In `close()`, call `state.close(...)` and then set `state = null`\n\n## Reference / similar design in codebase\n\n`AbstractFileItemWriter` uses an `OutputState` to encapsulate stream/channel lifecycle and binds the transactional writer close callback to that state, avoiding the same class of problems.\n",
    "labels": [
      "status: duplicate"
    ],
    "comments": [
      {
        "author": "fmbenhassine",
        "created_at": "2026-01-21T07:55:00Z",
        "body": "What a fantastic analysis! Thank you very much for doing that and for the PR! Really appreciated ðŸ™\n\n> Suggested fix direction\n\n> To make this safe, the resources created by a single open() (e.g. FileOutputStream/FileChannel/Writer/XMLEventWriter) should be encapsulated in a state object, and the TransactionAwareBufferedWriter close callback should be bound to that specific state instance.\n\n> In short:\n\n> Introduce an OutputState in StaxEventItemWriter to own those resources\nRegister the transactional close callback as TransactionAwareBufferedWriter(fileChannel, state::closeStream)\nIn close(), call state.close(...) and then set state = null\nReference / similar design in codebase\n\n> AbstractFileItemWriter uses an OutputState to encapsulate stream/channel lifecycle and binds the transactional writer close callback to that state, avoiding the same class of problems.\n\nThat's it. Making the `StaxEventItemWriter` use the same approach as the `AbstractFileItemWriter` is the way to go. I will check #5177 and get back to you.\n"
      }
    ],
    "closing_references": {
      "pull_requests": [],
      "commits": []
    }
  }
]