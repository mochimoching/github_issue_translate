# @Controllerなしの@RequestMappingがハンドラとして登録される [SPR-17622]

**Issue番号**: [#22154](https://github.com/spring-projects/spring-framework/issues/22154)

**状態**: closed | **作成者**: spring-projects-issues | **作成日**: 2018-12-23

**ラベル**: in: web, type: enhancement

**URL**: https://github.com/spring-projects/spring-framework/issues/22154

**関連リンク**:
- Commits:
  - [da2bcd8](https://github.com/spring-projects/spring-framework/commit/da2bcd837d58b03e3f696572d656153ee312521c)
  - [93bc27c](https://github.com/spring-projects/spring-framework/commit/93bc27cf2330e07f91a97b2934a0a0ef218cb928)
  - [b0fc461](https://github.com/spring-projects/spring-framework/commit/b0fc46113b4a93d532f56574571005ee3b47afaf)
  - [3bed306](https://github.com/spring-projects/spring-framework/commit/3bed306d1834465c0ea380c188bf9a320c06bc11)
  - [1d82544](https://github.com/spring-projects/spring-framework/commit/1d825440c328ef90b940ba6be8483aec184daeb4)
  - [a6b628a](https://github.com/spring-projects/spring-framework/commit/a6b628ab9a8d712e9aa06e7cb5cd6823d10daa1b)
  - [a791f13](https://github.com/spring-projects/spring-framework/commit/a791f13700da04f1f3fea4e9b2b64570f68d033b)
  - [eee4dd9](https://github.com/spring-projects/spring-framework/commit/eee4dd9f14954bb6fdc6b3198b3fe71c0c34ab3b)
  - [26c5968](https://github.com/spring-projects/spring-framework/commit/26c59681ad8e05cb65d573ca389269cccd13150d)
  - [3600644](https://github.com/spring-projects/spring-framework/commit/3600644ed1776dce35c4a42d74799a90b90e359e)
  - [32b8710](https://github.com/spring-projects/spring-framework/commit/32b87104892bc5d551947af125104b350d00a80b)
  - [436d71d](https://github.com/spring-projects/spring-framework/commit/436d71d01e89fe07508a9fb6b02960bb4acff200)
  - [d87fcfa](https://github.com/spring-projects/spring-framework/commit/d87fcfaf3eb403bb58ec4d71ce329fbbc32c2e00)
  - [18c8d14](https://github.com/spring-projects/spring-framework/commit/18c8d146d88cd00959b69b1071a96ff5496e01dd)

## 内容

**[Eugene Tenkaev](https://jira.spring.io/secure/ViewProfile.jspa?name=hronom)** が **[SPR-17622](https://jira.spring.io/browse/SPR-17622?redirect=false)** を作成しコメント:

http://projects.spring.io/spring-cloud/spring-cloud.html#spring-cloud-feign-inheritance のアプローチに従うと、

`UserService`にルートレベルの`@RequestMapping`を追加すると、Spring MVCアプリケーションでハンドラとして登録されてしまいます。

再現用のサンプルプロジェクト: https://github.com/Hronom/test-shared-mapping-interface

関連する議論:
* https://github.com/spring-cloud/spring-cloud-netflix/issues/466
* https://stackoverflow.com/questions/29284911/can-a-spring-cloud-feign-client-share-interface-with-an-spring-web-controller

これを適切に処理するには、`@RequestMapping`アノテーションのみを持つコントローラーの登録を避ける必要があります。

提案する解決策:

`@Controller`または`@RestController`アノテーションを持つ場合のみハンドラとして登録する。

---

**影響バージョン:** 5.1.3

**関連Issue:**
- [#16747](https://github.com/spring-projects/spring-framework/issues/16747) HttpInvokerProxyFactoryBeanに似たプロキシベースのRESTクライアントを導入

投票数: 1, ウォッチャー: 3


## コメント

### コメント 1 by spring-projects-issues

**作成日**: 2018-12-24

**[Sébastien Deleuze](https://jira.spring.io/secure/ViewProfile.jspa?name=sdeleuze)** がコメント:

要求の背景は理解できますが、クラスレベルの`@Component` + `@RequestMapping`は長い間サポートされているため、そのサポートを削除すると多くのアプリケーションが壊れてしまいます。

[Rossen Stoyanchev](https://jira.spring.io/secure/ViewProfile.jspa?name=rstoya05-aop)さん、[Arjen Poutsma](https://jira.spring.io/secure/ViewProfile.jspa?name=arjen.poutsma)さん、この変更要求についてご意見をいただけますか?


### コメント 2 by spring-projects-issues

**作成日**: 2018-12-24

**[Eugene Tenkaev](https://jira.spring.io/secure/ViewProfile.jspa?name=hronom)** がコメント:

[Sébastien Deleuze](https://jira.spring.io/secure/ViewProfile.jspa?name=sdeleuze)さん、説明を編集しました。アイデアは次のとおりです:

Spring MVCが、クラスレベルに`@Controller`または`@RestController`がある場合**のみ**エンドポイントを登録するようにする。

私の例が示すように:

現在、クラスに`@RequestMapping`のみがある場合、このクラスはSpring MVCでエンドポイントとして登録されます。


### コメント 3 by spring-projects-issues

**作成日**: 2018-12-25

**[Sébastien Deleuze](https://jira.spring.io/secure/ViewProfile.jspa?name=sdeleuze)** がコメント:

理解しています。ただし、明確にしたいのは、`@RequestMapping`単独では自動的にエンドポイントを公開しませんが、クラスレベルの`@RequestMapping`アノテーションを持つBeanは公開し、開発者はこれをさまざまな方法で使用しています。その1つが私の`@Component` + `@RequestMapping`の例です。

`@FeignClient`自体は`@Component`でメタアノテートされていませんが、`FeignClientFactoryBean`によってBeanとして登録されていると推測されます(確認はしていません)。これはSpring Frameworkの観点からは、`@Component` + `@RequestMapping`またはプログラマティックなBean登録と類似しています。

RESTエンドポイントの識別をより制限的にするという要求は理解できますし、`@FeignClient`で発生した問題は[#16747](https://github.com/spring-projects/spring-framework/issues/16747)にも当てはまります。しかし、このような破壊的変更も懸念しているため、このトピックについてより多くの知識とコンテキストを持つRossenとArjenのフィードバックを求めています。


### コメント 4 by rstoyanchev

**作成日**: 2019-01-18

クラスレベルの`@RequestMapping`は`@Controller`とは独立してヒントとして使用されます。`@RequestMapping`はインターフェースで使用できるため、コントローラーがAOPプロキシである場合、`@Controller`アノテーションはプロキシを通じてSpring MVCからアクセスできません。

@jhoeller さん、チェックを改善するオプションはありますか? 例えば、型レベルの`@RequestMapping`が`@Controller`なしで見つかり、Beanがプロキシの場合、さらにイントロスペクトして`@Controller`アノテーションを見つけられるか確認するなど。

Spring Data RESTにも同様の状況があり、[追加の`RequestMappingHandlerMapping`インスタンスを優先順位付けして配置し、特別なステレオタイプでエンドポイントを識別することで解決](https://docs.spring.io/spring-data/rest/docs/3.1.4.RELEASE/reference/html/#_repositoryresthandlermapping)しています。これは機能しますが、必要以上に複雑かもしれません。Spring MVCが特定の型をコントローラーとして扱わないようにすることもできますが、これも理想的ではなく、追加の設定が必要です。


### コメント 5 by remal

**作成日**: 2019-07-05

この問題は、デバッグが非常に困難なさまざまな問題を引き起こします。修正してください。以下の解決策を提案します:

1. `@RequestMapping`でアノテートされたクラスをハンドラとして扱わない。`@Controller`アノテーションのみを考慮すべき。

2. Spring Dataには`@NoRepositoryBean`があります。リクエストハンドラ用に同様のアノテーションを作成できます。例: `@NoRequestHandler`。

    * この場合、`@FeignClient`アノテーションにこの`@NoRequestHandler`アノテーションを付けることができます。

最初の解決策を実装することを提案します。

### コメント 6 by TannnnnnnnnnnnnnnnK

**作成日**: 2020-04-16

ハンドラの登録とリクエストマッピングの登録は、関連していても、互いに分離すべき異なるものです。

### コメント 7 by glockbender

**作成日**: 2020-06-16

この問題はまだ関連しています。進展はありますか?

### コメント 8 by odrotbohm

**作成日**: 2020-07-14

[#25386](https://github.com/spring-projects/spring-framework/issues/25386)の説明をここにコピーします:

**要約** – 現在の動作は、Spring Data RESTをカスタムコントローラーでカスタマイズしようとする人々にとっても問題があります。型レベルで`@RequestMapping`を使用するコントローラーが、間違ったハンドラマッピングに登録されてしまいます。

Rossenが[ここ](https://github.com/spring-projects/spring-framework/issues/22154#issuecomment-455561279)ですでに言及していましたが、最近StackOverflowの質問で再び浮上しました。

> `RequestMappingHandlerMapping.isHandler(...)`は、`@Controller`でアノテートされた型だけでなく、型レベルで`@RequestMapping`でアノテートされた型も取得します。これは、それらのコントローラーを処理すべき他の`HandlerMapping`インスタンスが登録されている場合に問題となります。
>
> その顕著な例がSpring Data RESTで、Spring DataリポジトリのHTTPリソースを公開するための専用マッピングを登録します。ユーザーは自分でコントローラーを宣言し、例えばアイテムリソースのURIと選択したHTTPメソッドのハンドラメソッドを宣言することで、これらのリソースを選択的にオーバーライドできます。そのコントローラーが型レベルで`@RequestMapping`を宣言すると、Spring MVCに登録されたものがそのクラスを取得し、同じURIパターンに対して定義された他のマッピングや、後続の`HandlerMapping`実装で利用可能な他のHTTPメソッドのサポートを見つけられなくなります。
> 
> これはユーザーから報告される非常に一般的なエラーシナリオです([このStackOverflow](https://stackoverflow.com/questions/62865947/restrepositorycontroller-hide-rest-repository-endpoints/62877864)の質問を参照)。また、かなり多くの実装詳細について説明する必要があるため、ユーザーへの説明が非常に困難です。
>
> 型レベルでの`@RequestMapping`の明示的な処理を削除すると、`@Controller`でもアノテートされていないコントローラー実装が自動的に取得されなくなるリスクがあります。Spring MVC関連のドキュメントで、型レベルで使用する際にアノテーションを組み合わせて使用しない例を実際には見つけていません。この問題の修正は、影響を受けるコントローラー型に`@Controller`もアノテートすることです。マイナーバージョンのリリースでは最適ではないかもしれませんが、6.0では少なくとも再評価すべきです。

### コメント 9 by mothinx

**作成日**: 2020-11-12

Feignクライアントでこの問題に遭遇し、特定するのに多くの時間を費やしました。誰かこの問題に取り組んでいますか?

### コメント 10 by odrotbohm

**作成日**: 2020-12-18

これは別のSpring Data RESTのissueでも発生しました: https://jira.spring.io/browse/DATAREST-1591

### コメント 11 by rstoyanchev

**作成日**: 2021-10-06

**チームの決定:** チーム間での議論の結果、短期的にはSpring Data RESTとSpring Cloud側でこの問題に対処します。

Spring Framework 6.0では、`@Controller`も存在しない限り、型レベルの`@RequestMapping`を持つクラスを検出候補として考慮しないことで、Spring Frameworkでもこれに対処します。

### コメント 12 by remal

**作成日**: 2021-10-06

@rstoyanchev さん、購読できる対応するSpring Cloudのチケットはありますか?

### コメント 13 by rstoyanchev

**作成日**: 2021-10-14

@remal さん、はい、こちらでフォローできます: https://github.com/spring-cloud/spring-cloud-openfeign/issues/547

### コメント 14 by OrangeDog

**作成日**: 2024-01-23

以前の動作では、`@Bean`メソッドでコントローラーを宣言および構築できました。今は、クラスに`@Controller`を追加する必要があるため、`@ComponentScan`によって自動的に宣言され、追加の除外フィルタが必要になります。
