# 非同期実行される各メソッド(例: クラスレベルの@Async)に対してFutureまたはvoid戻り値宣言を強制する

**Issue番号**: [#27734](https://github.com/spring-projects/spring-framework/issues/27734)

**状態**: closed | **作成者**: djechelon | **作成日**: 2021-11-25

**ラベル**: in: core, type: enhancement

**URL**: https://github.com/spring-projects/spring-framework/issues/27734

**関連リンク**:
- Commits:
  - [9a513cf](https://github.com/spring-projects/spring-framework/commit/9a513cfdea9020c6ed2cf3f37711ed4e31d7c310)

## 内容

Springで`@Async`アノテーション付きクラスを使用していて、奇妙な動作を発見しました。**コードには根本的なエラーがあります**。残念ながら、この投稿は長く詳細になる必要があります。

Swagger generatorで生成された同期REST APIが既にあるとします。以下のコードではドキュメントレベルのアノテーションをすべて省略しています。

```java
public interface TaxonomiesApi {
    ResponseEntity<GenericTaxonomyItem> disableItem(Integer idTaxonomyType, String idTaxonomy, String appSource);
}
```

このAPIは`RestTemplate`で簡単に実装できますが、内部の詳細については説明しません。

次に、APIを利用する開発者に非同期バージョンを提供したいとします。私が行ったのは、検索と置換を駆使して別のインターフェースを作成することでした🥋🥋

```java
@Async
public interface TaxonomiesApiAsync extends TaxonomyApi {
    default CompletableFuture<ResponseEntity<GenericTaxonomyItem>> disableItemAsync(Integer idTaxonomyType, String idTaxonomy, String appSource) {
        try {
            return completedFuture(this.disableItem(idTaxonomyType, idTaxonomy, appSource));
        } catch (Exception ex) {
            return failedFuture(ex);
        }
    }
}
```

検索と置換により、Springの`@Async`アノテーションによってバックアップされるべきすべてのメソッドの非同期版を基本的に作成しました。私の元々のアイデアは、同期メソッドはそのまま呼び出すことができるが、`TaxonomiesApiAsync`をインスタンス化すれば非同期バージョンにもアクセスできるというものでした。

クラスに同期メソッドと非同期メソッドの両方が含まれている場合、インターフェースレベルで`@Async`アノテーションを適用することで**根本的な誤り**を犯したことを発見しました。同期の`disableItem`が同じ`@Async`コンテキストで実行されることがわかりました。設計通り(正しく)、Springはインターフェースレベルで`@Async`アノテーションを見つけたため、継承されたメソッドを含む**すべてのメソッド**が非同期に呼び出されました。

しかし、メソッドは常にnullを返しました。デバッグしてコードを見ると、Springは呼び出されたメソッドの戻り値を`Future`の場合**のみ**解決しようとすることがわかりました。戻り値が_現在_のオブジェクトである場合はどうなるでしょうか?

つまり、戻り値が`Future<ResponseEntity<GenericTaxonomyItem>>`ではなく、単なる`ResponseEntity<GenericTaxonomyItem>`である場合、Springは例外をスローすることも、その値を直接返すこともしません。

正常に動作する呼び出しコードの例(別のメソッドを呼び出しています):

```java
protected CompletableFuture<Set<TaxonomyLegalEntityDTO>> importTaxonomyLegalEntities(int userId) {
    TaxonomySearchParameters searchParameters = new TaxonomySearchParameters();
    searchParameters.setIdTaxonomyType(amlcProperties.getTaxonomies().getTaxonomyLegalEntitiesId());
    searchParameters.setLogicalState(1);
    return taxonomiesApiAsync.getAllTaxonomyItemsAsync(searchParameters)
            .thenApply(ResponseEntity::getBody)
            .thenApply(taxonomyLegalEntityMasterDbMapping::toLegalEntity)
            .whenComplete(traceLoggerConsumer("Legal entity"))
            .thenApply(dtos -> taxonomyLegalEntityManager.mergeFromMasterDb(dtos, userId))
            .whenComplete((ignored, ex) -> {
                if (ex != null)
                    log.error("Error importing legal entities: " + ex.getMessage(), ex);
            })
            .thenApply(TaxonomyMasterDbMergeDTO::getSnapshot);
}
```

動作しないコードの例。CompletableFutureの結果は常にnullです。このコードでは、APIサービスに_埋め込まれた_executorを使用するのではなく、消費側サービスに注入されたexecutorを使用することにしました。そのため、executorで同期メソッドを実行し、同じ結果を期待しました。

```java
protected CompletableFuture<Set<TaxonomyLegalEntityDTO>> importTaxonomyLegalEntities(int userId) {
    TaxonomySearchParameters searchParameters = new TaxonomySearchParameters();
    searchParameters.setIdTaxonomyType(amlcProperties.getTaxonomies().getTaxonomyLegalEntitiesId());
    searchParameters.setLogicalState(1);
    return CompletableFuture.supplyAsync(() -> taxonomiesApi.getAllTaxonomyItems(searchParameters), taxonomyBatchImportServiceExecutor)
            .thenApply(ResponseEntity::getBody)
            .thenApply(taxonomyLegalEntityMasterDbMapping::toLegalEntity)
            .whenComplete(traceLoggerConsumer("Legal entity"))
            .thenApplyAsync(dtos -> taxonomyLegalEntityManager.mergeFromMasterDb(dtos, userId))
            .whenComplete((ignored, ex) -> {
                if (ex != null)
                    log.error("Error importing legal entities: " + ex.getMessage(), ex);
            })
            .thenApply(TaxonomyMasterDbMergeDTO::getSnapshot);
}
```

この問題のデバッグに1時間費やしたので、問題をここに記録するために仕事後の時間をさらに費やすことにしました。

**提案する修正**

リンクしたコードでは、`instanceof`チェックが失敗した場合、返される値は単にnullです。まだ影響を理解していませんが、Futureでない場合に値をFutureからアンラップしないようにするのはどうでしょうか? つまり`return result`です。

## コメント

### コメント 1 by mdeinum

**作成日**: 2021-11-26

> ターゲットメソッドのシグネチャに関しては、任意のパラメータ型がサポートされます。ただし、戻り値の型は`void`または`Future`に制限されます。後者の場合、より豊富な非同期タスクとの対話と、さらなる処理ステップとの即座の合成を可能にする、より具体的な`ListenableFuture`または`CompletableFuture`型を宣言できます。

ドキュメントには戻り値の型の制限として`void`または`Future`のみが記載されています。特定の型の戻り値を許可することは意味がありません。なぜなら、それはメソッド呼び出しを再び同期的にしてしまうからです。`Future.get`を実行する必要があり、これはブロッキングであるため、`@Async`が無意味になります。

したがって、戻り値の型が`Future`でない場合、もう一つの許可された戻り値が`void`であるため、`null`を返すことができます。

解決策として、IMHOでは、戻り値の型として`void`または`Future`のみがサポートされているという明確なメッセージの例外の方が良いでしょう。

### コメント 2 by rstoyanchev

**作成日**: 2021-11-26

ドキュメントに記載されており、@mdeinumが指摘したように、戻り値の型は`Future`または`void`でなければなりません。そうでない場合、呼び出しコードはいずれにせよブロックする必要があり、Executorスレッドを関与させることが無意味になり、同期的であるべき非同期メソッドになります。

@jhoeller、voidまたはFutureを返さないメソッドをバイパスする機会が見られない限り、これはクローズできると思います。

### コメント 3 by jhoeller

**作成日**: 2021-11-29

メソッドを非同期に実行しようとするたびに、非Future/void戻り値型宣言に対して明示的に例外をスローすることを検討しています。明示的にアノテーションされたメソッドではあまり問題にならないかもしれませんが、クラスレベルの`@Async`宣言は、特定のメソッドが不一致の場合に追跡することが確かに難しくなります。

### コメント 4 by LifeIsStrange

**作成日**: 2022-01-04

初心者の質問です @jhoeller、体系的にinstanceof/reflectionチェックを行っているため、*速度低下を引き起こす可能性がある*と思いますが、このチェックをdev/debugモードでのみ有効にし、releaseモードでは無効にする方が良くないでしょうか?

### コメント 5 by djechelon

**作成日**: 2022-01-04

@LifeIsStrange コードを見ればわかるように、行われているのは`returnType`に対する`==`チェックで、これは既に利用可能です(既にreflectされています)。したがって、オーバーヘッドは追加されません。

`instanceof`のパフォーマンスに関する質問については、[興味深い記事](https://stackoverflow.com/questions/103564/the-performance-impact-of-using-instanceof-in-java)を見つけました。**tl;dr**は以下の通りです:

> Java 1.8ではinstanceofが最速のアプローチですが、getClass()も非常に近いです。

とはいえ、この修正には適用されません。
