# @TransactionalがCGLibプロキシのパッケージプライベートメソッドで動作しない

**Issue番号**: [#25582](https://github.com/spring-projects/spring-framework/issues/25582)

**状態**: closed | **作成者**: odrotbohm | **作成日**: 2020-08-12

**ラベル**: in: data, type: enhancement

**URL**: https://github.com/spring-projects/spring-framework/issues/25582

**関連リンク**:
- Commits:
  - [9efa99e](https://github.com/spring-projects/spring-framework/commit/9efa99e0d84759d321c1676f0f4ac7d43f125eda)
  - [37bebea](https://github.com/spring-projects/spring-framework/commit/37bebeaaaf294ef350ec646604124b5b78c6e690)
  - [c8a4026](https://github.com/spring-projects/spring-framework/commit/c8a40265128ceb56af2176911d46dcc1e92f9a39)

## 内容

`AnnotationTransactionAttributeSource`には、パブリックメソッドのみを考慮するかどうかのフラグがあり、デフォルトで`true`に設定されています。これは、JDKプロキシがプロキシを適用する主要な方法だった時代に由来すると思われます。JDKプロキシでは、パブリックメソッドのみがインターセプト可能です。

CGLibプロキシでは状況が異なります。パッケージプライベートメソッド*は*プロキシ上で呼び出すことができ、AOPインフラストラクチャを適切に通過します。しかし、トランザクション属性のルックアップは、上記のフラグのために早期に中止されます。これにより混乱を招く状況が生じます(`@EnableGlobalMethodSecurity`と`@EnableTransactionManagement`が適用されているとします):

```java
@Component
class MyClass {

  @Secured(…)
  @Transactional
  void someMethod() { … }
}
```

この例では、セキュリティアノテーション*は*適用されます。セキュリティインフラストラクチャはこのようなフラグを使用せず、メソッド呼び出しに対してアドバイスが登録されるためです。一方、トランザクショナルアノテーション*は*適用されません。メソッドがそもそもトランザクショナルアノテーションについて検査されないためです。

`@EnableTransactionManagement`の`proxyTargetClass`属性に基づいてフラグを反転させることが理にかなっているか検討すべきです。それが`true`に設定されている場合、CGLibプロキシが作成されるため、パッケージプライベートメソッドでもトランザクションアノテーションを考慮すべきです。これは、Spring Bootがこのフラグをデフォルトで`true`に設定しているコンテキストで特に重要と思われます。

現在の回避策は[このコミット](https://github.com/quarano/quarano-application/commit/4d4e8239de7ee0a4a6b7ef4af1b8431932dee8b5)で示されています。`PriorityOrdered`の`BeanPostProcessor`を使用してリフレクティブにフラグを反転させ、その特定のケースでは常にCGLibプロキシで実行することが分かっているため、設定を考慮していません。

## コメント

### コメント 1 by sbrannen

**作成日**: 2020-08-14

参考までに、TestContextフレームワークは実際にこのフラグを`false`に設定して、TestNGとJUnit Jupiterのパッケージプライベートな`@Test`メソッドをサポートしています。

https://github.com/spring-projects/spring-framework/blob/13183c89ce1eb178793e542753cd78f3d9908164/spring-test/src/main/java/org/springframework/test/context/transaction/TransactionalTestExecutionListener.java#L151

本番環境での変更(オプトイン機能として)に賛成です。それを踏まえて、`for: team-attention`ラベルを追加しました。

### コメント 2 by odrotbohm

**作成日**: 2020-08-14

> 本番環境での変更(オプトイン機能として)に賛成です。

これはオプトイン修正にすべきではないと思います。現在、上記のようにメソッドへのアノテーションの適用性に不整合が生じているためです。また、他のアノテーションについてはこれを明示的に有効にする必要がないのに、なぜこの特定のケースでそうする必要があるのでしょうか?

これが長い間見過ごされてきた理由は、人々が公開する必要のないコードでさえ、最初からすべてを`public`にすることに慣れているからだと思います(主にIDEの誤ったガイダンスによるもの)。

### コメント 3 by sbrannen

**作成日**: 2020-08-14

> > 本番環境での変更(オプトイン機能として)に賛成です。
> 
> これはオプトイン修正にすべきではないと思います。現在、上記のようにメソッドへのアノテーションの適用性に不整合が生じているためです。また、他のアノテーションについてはこれを明示的に有効にする必要がないのに、なぜこの特定のケースでそうする必要があるのでしょうか?

では、一部のプロジェクトで変更が問題を引き起こす場合に備えて、古い方法に戻すためのオプトイン機能を用意する方が良いかもしれません。

> これが長い間見過ごされてきた理由は、人々が公開する必要のないコードでさえ、最初からすべてを`public`にすることに慣れているからだと思います(主にIDEの誤ったガイダンスによるもの)。

はい、同意します。

### コメント 4 by odrotbohm

**作成日**: 2020-09-01

別のユーザーがこれにつまずきました: https://stackoverflow.com/questions/63675153/transactional-annotation-doesnt-solve-org-hibernate-lazyinitializationexception

### コメント 5 by odrotbohm

**作成日**: 2020-10-25

[ここ](https://github.com/quarano/quarano-application/blob/c35b48635af42f5a1b1cb3cff573ffcf477b47ed/backend/src/main/java/quarano/Quarano.java#L90-L139)で、現在プロジェクトで問題を回避する方法を示しています。Beanライフサイクルの非常に早い段階で`AnnotationTransactionAttributeSource`を取得し、`publicMethodsOnly`フラグを反転させています。

### コメント 6 by andrei-ivanov

**作成日**: 2020-10-25

これを試してみてはいかがでしょうか 😀

> hibernate.enable_lazy_load_no_trans (例: true または false (デフォルト値))
>
>    指定されたトランザクショナル永続化コンテキストの外でLazy ProxyまたはCollectionを初期化します。
>    この設定を有効にするとLazyInitializationExceptionは解消されますが、Sessionがクローズされる前にすべてのプロパティが適切に初期化されることを保証するフェッチプランを使用する方が良いです。
>
>    実際には、この設定を有効にすべきではないでしょう。
