# @Transactional does not work on package protected methods of CGLib proxies

**Issueç•ªå·**: #25582

**çŠ¶æ…‹**: closed | **ä½œæˆè€…**: odrotbohm | **ä½œæˆæ—¥**: 2020-08-12

**ãƒ©ãƒ™ãƒ«**: in: data, type: enhancement

**URL**: https://github.com/spring-projects/spring-framework/issues/25582

**é–¢é€£ãƒªãƒ³ã‚¯**:
- Commits:
  - [9efa99e](https://github.com/spring-projects/spring-framework/commit/9efa99e0d84759d321c1676f0f4ac7d43f125eda)
  - [37bebea](https://github.com/spring-projects/spring-framework/commit/37bebeaaaf294ef350ec646604124b5b78c6e690)
  - [c8a4026](https://github.com/spring-projects/spring-framework/commit/c8a40265128ceb56af2176911d46dcc1e92f9a39)

## å†…å®¹

`AnnotationTransactionAttributeSource` contains a flag whether to only consider public methods, set to `true` by default. I assume that stems from the times when JDK proxies where the primary way of applying proxies and with those only public methods can be intercepted anyway.

With CGLib proxies this is different. Package private methods *can* be invoked on the proxy and properly make their way through the AOP infrastructure. However, the lookup of transaction attributes is eagerly aborted due to the flag mentioned above. This creates confusing situations (assume `@EnableGlobalMethodSecurity` and `@EnableTransactionManagement` applied):

```java
@Component
class MyClass {

  @Secured(â€¦)
  @Transactional
  void someMethod() { â€¦ }
}
```

In this example, the security annotations *are* applied as the security infrastructure does not work with a flag like this and the advice is registered for the method invocation. The transactional annotations are *not* applied, as the method is not inspected for transactional annotations in the first place.

I wonder if it makes sense to flip the flag based on the `proxyTargetClass` attribute in `@EnableTransactionManagement`. If that is set to true, CGLib proxies are created and thus, transaction annotations should be regarded on package protected methods. This seems to be especially important in the context of Spring Boot setting this flag to `true` by default.

A current workaround is demonstrated in [this commit](https://github.com/quarano/quarano-application/commit/4d4e8239de7ee0a4a6b7ef4af1b8431932dee8b5), which uses a `PriorityOrdered` `BeanPostProcessor` to reflectively flip the flag, not considering any configuration as in that particular case we know we're always gonna run with CGLib proxies.

## ã‚³ãƒ¡ãƒ³ãƒˆ

### ã‚³ãƒ¡ãƒ³ãƒˆ 1 by sbrannen

**ä½œæˆæ—¥**: 2020-08-14

FWIW, the TestContext framework actually sets the flag to `false` in order to support package-private `@Test` methods in TestNG and JUnit Jupiter.

https://github.com/spring-projects/spring-framework/blob/13183c89ce1eb178793e542753cd78f3d9908164/spring-test/src/main/java/org/springframework/test/context/transaction/TransactionalTestExecutionListener.java#L151

I'd be in favor of making production changes here (as an opt-in feature). In light of that, I've added the `for: team-attention` label.

### ã‚³ãƒ¡ãƒ³ãƒˆ 2 by odrotbohm

**ä½œæˆæ—¥**: 2020-08-14

> I'd be in favor of making production changes here (as an opt-in feature).

I really don't think it should be an opt-in fix as it currently creates an inconsistency in the applicability of annotations to methods as shown above. Also, you don't have to explicitly enable this for other annotations, why would you have to in this particular case?

I guess the reason that this has been overseen for so long is that folks are used to make everything and the world `public` in the first place even on code that doesn't need to be public (mostly due to misguidance by their IDEs).

### ã‚³ãƒ¡ãƒ³ãƒˆ 3 by sbrannen

**ä½œæˆæ—¥**: 2020-08-14

> > I'd be in favor of making production changes here (as an opt-in feature).
> 
> I really don't think it should be an opt-in fix as it currently creates an inconsistency in the applicability of annotations to methods as shown above. Also, you don't have to explicitly enable this for other annotations, why would you have to in this particular case?

Then perhaps an opt-in feature for switching it back to the old way, in case the change causes issues for some projects.

> I guess the reason that this has been overseen for so long is that folks are used to make everything and the world `public` in the first place even on code that doesn't need to be public (mostly due to misguided guidance by their IDEs).

Yes, I agree.

### ã‚³ãƒ¡ãƒ³ãƒˆ 4 by odrotbohm

**ä½œæˆæ—¥**: 2020-09-01

Another user stumbling over this: https://stackoverflow.com/questions/63675153/transactional-annotation-doesnt-solve-org-hibernate-lazyinitializationexception

### ã‚³ãƒ¡ãƒ³ãƒˆ 5 by odrotbohm

**ä½œæˆæ—¥**: 2020-10-25

[Here](https://github.com/quarano/quarano-application/blob/c35b48635af42f5a1b1cb3cff573ffcf477b47ed/backend/src/main/java/quarano/Quarano.java#L90-L139)'s how I currently work around the issue in a project. I get hold of the `AnnotationTransactionAttributeSource` very early in the bean lifecycle and flip the `publicMethodsOnly` flag.

### ã‚³ãƒ¡ãƒ³ãƒˆ 6 by andrei-ivanov

**ä½œæˆæ—¥**: 2020-10-25

Maybe you can try this one ðŸ˜€

> hibernate.enable_lazy_load_no_trans (e.g. true or false (default value))
>
>    Initialize Lazy Proxies or Collections outside a given Transactional Persistence Context.
>    Although enabling this configuration can make LazyInitializationException go away, itâ€™s better to use a > fetch plan that guarantees that all properties are properly initialized before the Session is closed.
>
>    In reality, you shouldnâ€™t probably enable this setting anyway.


