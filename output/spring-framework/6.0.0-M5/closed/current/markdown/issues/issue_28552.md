# Deprecate trailing slash match and change default value from true to false

**Issue番号**: #28552

**状態**: closed | **作成者**: vpavic | **作成日**: 2022-06-01

**ラベル**: in: web, type: enhancement

**URL**: https://github.com/spring-projects/spring-framework/issues/28552

**関連リンク**:
- Commits:
  - [d96b4a0](https://github.com/spring-projects/spring-framework/commit/d96b4a046342a5d886eeb967c05f8b7f95b6dfb1)
  - [4bff95a](https://github.com/spring-projects/spring-framework/commit/4bff95a18017b7a9f603315c606e8f31e74bd658)
  - [0098f29](https://github.com/spring-projects/spring-framework/commit/0098f2931adaa919ddfe66eda2ef620036e7044a)
  - [b312eca](https://github.com/spring-projects/spring-framework/commit/b312eca39177cf9bd588c52c3b56ca42b4f75271)
  - [a81ba68](https://github.com/spring-projects/spring-framework/commit/a81ba68da19efc6f09fe70497f4cf5d4d6c3b190)
  - [93b343f](https://github.com/spring-projects/spring-framework/commit/93b343fbd605d05e3b209bd69f011022eccf72ec)

## 内容

> Whether to match to URLs irrespective of the presence of a trailing slash. If enabled a method mapped to `"/users"` also matches to `"/users/"`.
> The default value is `true`.

Even though this behavior has been long present in Spring, it introduces ambiguity that can (combined with some other choices) easily have consequences in shape of security vulnerabilities. Consider this example:

```java
@SpringBootApplication
@RestController
public class SampleApplication {

    public static void main(String[] args) {
        SpringApplication.run(SampleApplication.class, args);
    }

    @GetMapping("/resources")
    String resources() {
        return "Hello from /resources";
    }

    @GetMapping("/resources/{id}")
    String resourceById(@PathVariable Long id) {
        return "Hello from /resources/" + id;
    }

    @Bean
    SecurityFilterChain filterChain(HttpSecurity httpSecurity) throws Exception {
        return httpSecurity
                .authorizeHttpRequests(requests -> {
                    requests.antMatchers("/resources").hasRole("admin");
                    requests.antMatchers("/resources/**").hasRole("user");
                    requests.anyRequest().denyAll();
                })
                .httpBasic(Customizer.withDefaults())
                .build();
    }

}
```

```properties
spring.security.user.password=password
spring.security.user.roles=user
```

Default user (with role `user`) will get `403` attempting to `GET /resources` but can avoid protection by issuing `GET /resources/`, which wouldn't be possible with trailing slash matching disabled.

Let me note that I'm aware that using `mvcMatchers` instead of `antMatchers` would have prevented this issue but that doesn't change the fact that there are many configurations out there relying on `antMatchers` and that sometimes `antMatchers` are simply more suitable for other reasons.

Also, I personally see little real benefit of having trailing slash matching enabled because:
- if application renders server-side generated views navigation is either way established using hyperlinks
- if application exposes APIs then even more so it is expected that requests are aligned with the API docs

For places where it's really needed for application to respond to both requests, I'd argue that it's either way better solution to configure redirects instead of application wide ambiguous request mappings.

Please consider making this change for `6.0`.

## コメント

### コメント 1 by rstoyanchev

**作成日**: 2022-06-08

I think most users would would expect that a trailing slash doesn't make a difference. From that perspective, the default is not unreasonable, and more than just HATEOAS style navigation or API guidance, even just manually typing a URL somewhere.

If we change the default, many would look to change it back, so overall it's hard to avoid the need to align Spring Security with with Spring MVC through `mvcMatchers`. One could argue that it's a safer default but this applies only when used with Spring Security. It's not unsafe by itself. 

For configuring redirects, do you mean externally, like in a proxy? That would solve the problem at a different level, before Spring Security and Spring MVC, so I would be more interested in that direction but we can only make it a recommendation, and we can still make such a recommendation independent of this.





### コメント 2 by vpavic

**作成日**: 2022-06-09

> From that perspective, the default is not unreasonable, and more than just HATEOAS style navigation or API guidance, even just manually typing a URL somewhere.

I can see _manually typing a URL_ as a real argument only in case of web apps (not APIs) and even there it's only potentially useful for a few select URLs that are considered to be entry points into the application and are likely to be directly entered by the users.

> One could argue that it's a safer default but this applies only when used with Spring Security. It's not unsafe by itself.

This is the part I strongly disagree with - what Spring Security does is nothing special nor unique. You can end up with the same kind of risks with other Java filter based security frameworks (for example, Apache Shiro) or by applying security (authorization) in an external component that sits in front of your Spring application. After all, on a high level, conceptually these all take the same approach.

> For configuring redirects, do you mean externally, like in a proxy?

Either externally in a proxy or using something like [Tuckey UrlRewriteFilter](https://www.tuckey.org/urlrewrite/) or even simply using `ViewControllerRegistry::addRedirectViewController` to add redirects where needed.

What I would like to see in Spring are the defaults that are not ambiguous and are therefore less prone to abuse. When I see a handler annotated with `@GetMapping("/api/resources")` that it really maps to only what I see, unless I opt into any additional (ambiguous) behavior explicitly. This change together with #23915 would achieve that.

### コメント 3 by rstoyanchev

**作成日**: 2022-06-10

I'm not necessarily disagreeing. I'm merely making the point that by itself, trailing slash is not unsafe. It's only when combined with a proxy or filter that also interprets URLs, where it becomes a problem, and the problem more generally is that there may be differences, which could go both ways. 

That said, this is also the reason, I've come to see over time that URL paths should be left alone as is as much as possible, avoiding normalization as much as possible. It's the only way for frameworks to minimize differences and align naturally. This is also why `PathPatternParser` was designed to not decode the full path in order to match to mappings, unlike `AntPathMatcher`, doesn't even support suffix patterns, etc.

In any case, the only way to really make a significant difference here I think is to deprecate the trailingSlash option entirely and encourage an alternative solution, like a proxy or filter to redirect. That enforces being more precise about where you want to do that exactly, and it can be done ahead of security decisions. Otherwise the possibility for a mismatch between web and security frameworks remains. It's just too easy to flip the default back and not think about it again.

This is something that we'll discuss as a possibility for 6.0.


### コメント 4 by vpavic

**作成日**: 2022-06-10

> In any case, the only way to really make a significant difference here I think is to deprecate the trailingSlash option entirely and encourage an alternative solution, like a proxy or filter to redirect.

I like that even better. Thanks for the feedback.

### コメント 5 by rstoyanchev

**作成日**: 2022-06-21

**Team decision:** we'll go ahead with this. It aligns with various other path matching changes we've made in 5.2 and 5.3 such suffix pattern matching, path segment trimming, and path decoding, to make path matching more transparent and explicit. 

### コメント 6 by wilkinsona

**作成日**: 2022-06-21

Will the default be changed to false as part of this deprecation?

### コメント 7 by rstoyanchev

**作成日**: 2022-06-21

Yes, I'm thinking that we might as well and that we'll have to, since otherwise you'd need to set it in order to stop using it. We had the same issue with suffix pattern matching. 

### コメント 8 by rstoyanchev

**作成日**: 2022-06-29

The trailing slash option is now deprecated and set to `false` in all applicable places. The change applies mainly to annotated controllers, since `SimpleUrlHandlerMapping`, it turns out, was already set to `false` by default. Nevertheless, it's now deprecated throughout and to be removed eventually.

### コメント 9 by bclozel

**作成日**: 2022-07-01

I've just found this while browing the code @rstoyanchev :

https://github.com/spring-projects/spring-framework/blob/50240bb609b6441390d436005a7f2e7a4cdf5454/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/RequestMappingHandlerMapping.java#L85

Should this value be changed as well?

### コメント 10 by rstoyanchev

**作成日**: 2022-07-01

Looks like it, yes.

### コメント 11 by MartinHaeusler

**作成日**: 2022-12-02

This little stunt just cost us over 10 man-hours of pure frustration staring at 404 issues. We debugged through the entire security filter chain, the servlet, everything (great fun!) - until we arrived at the path matchers where it became apparent that the difference between the pattern (and its path placeholders) and the provided path was only the trailing slash. This may be apparent in small applications, but we have over 300 endpoint mappings. If the little phrase `404` would have appeared somewhere in the lengthy migration notes, we would have found it.

### コメント 12 by bclozel

**作成日**: 2022-12-02

@MartinHaeusler I'm sorry you went through this. Maybe we can improve the documentation to avoid the same issue for other developers. Can you share at which documentation you were looking at while working on this?

### コメント 13 by MartinHaeusler

**作成日**: 2022-12-02

@bclozel we were looking at this:

https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-3.0-Migration-Guide

But given how big Spring Boot is (with all its modules) it's hard to tell which parts of this document are even relevant for any given application. We spent some time on google looking for "Spring Boot 3 404", but the search results produced nothing specific for the latest version. Up to this point, we were not even **aware** that some clients were sending trailing slashes to our endpoints, it just "happened to work". That's why the section on trailing slashes didn't really catch any attention. Making the migration guide easier to search through (i.e. "if you do not update X, you will receive error Y") would have been great. If there was any mention of "if your application relied on this behavior, you will receive HTTP 404 errors" in the migration guide, we would have found it instantly... No hard feelings. We are now aware of it and can move on.

### コメント 14 by bclozel

**作成日**: 2022-12-02

@MartinHaeusler I've added a quick mention of "HTTP 404 errors" in [the dedicated section of the Spring Boot migration guide](https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-3.0-Migration-Guide#spring-mvc-and-webflux-url-matching-changes), hopefully this will help others. Thanks for bringing this up.

### コメント 15 by armlesshobo

**作成日**: 2022-12-20

Are there any considerations for trimming trailing slashes by default?

### コメント 16 by kdebski85

**作成日**: 2022-12-29

@bclozel  Migration guide should also provide a workaround for SpingFlux, not only SpringMVC.
Something like:

```java
@Configuration
class WebConfiguration implements WebFluxConfigurer {

    @Override
    public void configurePathMatching(PathMatchConfigurer configurer) {
        configurer.setUseTrailingSlashMatch(true);
    }
}

### コメント 17 by philwebb

**作成日**: 2022-12-29

@kdebski85 Thanks for the suggestions, I've updated the wiki.

### コメント 18 by kdebski85

**作成日**: 2022-12-30

@philwebb I found that the workaround with WebFluxConfigurer does not work when `authorizeExchange` with `pathMatchers` is used.
I created https://github.com/spring-projects/spring-framework/issues/29755 for this issue.

### コメント 19 by lpandzic

**作成日**: 2023-01-31

This seems pretty problematic to me on a grander scale of things.
Consider that many Spring Boot applications are in fact APIs served to many different customers over which the API developer has very little, if any, control over.
Since this worked before Spring Boot 3 if any of those customers used legacy behavior suddenly application developer is in a impossible situation where he's essentially forced to support this legacy behavior indefinitely. I'm saying indefinitely because I find it highly unlikely anyone will be able to convince all of their customers  to fix it in their code for what seems to be for superficial or puristic reasons.

Now I'm not necessarily against this  change, I just expect Spring Framework teams will get a lot of flak for this because of the situation explained above. It puts developers into an impossible situation which can be hard to detect at first and cause a lot of frustration.

At Infobip I know where to fix this for all our public API's without duplicating this change all over our codebase, but I'm not sure everyone will be that lucky.

### コメント 20 by dkoding

**作成日**: 2023-02-22

This brilliant move just cost our teams hundreds of man-hours. So thanks for that.

