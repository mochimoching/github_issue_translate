# WebClientを使用してFluxのオブジェクトをJSONとして送信する際にcollectListを避ける

**課題番号**: #28398

**状態**: closed | **作成者**: micopiira | **作成日**: 2022-04-29

**ラベル**: in: web, type: enhancement

**URL**: https://github.com/spring-projects/spring-framework/issues/28398

**関連リンク**:
- Commits:
  - [ce56846](https://github.com/spring-projects/spring-framework/commit/ce568468aed09147e335b5d5a717e1b2dac581a8)

## 内容

WebClientを使用して、オブジェクトのFluxをリクエストボディに「Content-Type: application/json」で送信する際に、Flux全体をメモリ内でリストとして収集することを避けることは可能でしょうか？

何百万もの要素を含むFluxがあり、ターゲットサーバーがストリーミングでないコンテンツタイプしか受け付けない場合、`Jackson2JsonEncoder`はFluxに対して「collectList()」を呼び出し、メモリ不足になる可能性があります。

`Jackson2JsonEncoder`は、利用可能になったオブジェクトを順次書き込むことはできないのでしょうか？

## コメント

### コメント 1 by poutsma

**作成日**: 2022-05-09

可能ですが、Content-Typeとして`application/json`ではなく、`application/x-ndjson`を使用する必要があります。

JSONコンテンツを個別に書き込むのは、まとめて書き込むよりも大きなオーバーヘッドがあります。そのため、`Jackson2JsonEncoder`はデフォルトでリストに収集してシリアライズします。ストリーミングMIMEタイプ（デフォルトでは`application/x-ndjson`に設定されていますが、`streamingMediaTypes`プロパティで変更可能）を指定すると、`Jackson2JsonEncoder`はリストを収集せず、到着した順にストリームし、要素間に改行を挿入します。

これで質問に答えられましたでしょうか？

### コメント 2 by micopiira

**作成日**: 2022-05-09

こんにちは。`application/json`しか受け付けないサーバーにPOSTしようとしています。WebClientよりも低レベルな、例えばreactor-nettyのようなもので、次のようなことができます：

```java
Flux<String> flux = Flux.range(0, 1000000).map(Object::toString);
final Mono<HttpClientResponse> response = httpClient.headers(headers -> {
            headers.set(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON.toString());
            headers.set(HttpHeaders.ACCEPT, MediaType.APPLICATION_JSON.toString());
        }).post()
        .uri("/url")
        .send(ByteBufFlux.fromString(flux
                .map(o -> {
                    try {
                        return objectMapper.writeValueAsString(o);
                    } catch (JsonProcessingException e) {
                        throw new RuntimeException(e);
                    }
                }).zipWith(Flux.just(",").repeat(), (a, b) -> a + b).startWith("[").concatWithValues("]")))
        .response();
```

これにより、私の知る限り、すべてのオブジェクトを待つことなく、利用可能になった時点でターゲットにストリームできます。

このような動作をWebClientで実装することは可能でしょうか、それともreactor-nettyのような低レベルクライアントを使い続けるべきでしょうか？

### コメント 3 by poutsma

**作成日**: 2022-05-10

>application/jsonしか受け付けないサーバーにPOSTしようとしています

`Jackson2JsonEncoder`の`streamingMediaTypes`プロパティをデフォルトから`application/json`に変更することで、ストリーミング動作をトリガーできます。リファレンスドキュメントには[コーデックのデフォルト設定を変更する方法](https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-config-message-codecs)が説明されています。

### コメント 4 by micopiira

**作成日**: 2022-05-11

なるほど。しかし、「そのままでは」有効なJSONを生成しません。以下のように試してみました：

```java
private final WebClient webClient = WebClient.builder()
   .baseUrl("http://localhost:8080/")
   .codecs(clientCodecConfigurer -> {
     final Jackson2JsonEncoder jackson2JsonEncoder = new Jackson2JsonEncoder();
     jackson2JsonEncoder.setStreamingMediaTypes(List.of(MediaType.APPLICATION_JSON));
     clientCodecConfigurer.defaultCodecs().jackson2JsonEncoder(jackson2JsonEncoder);
    })
   .build();

    Flux<MyEntity> flux = ...;
    webClient.post()
               .uri("/")
               .contentType(MediaType.APPLICATION_JSON)
               .accept(MediaType.APPLICATION_JSON)
               .body(flux, MyEntity.class)
               .retrieve()
               .bodyToMono(MyResponse.class)
```

これではJSONが配列でラップされず、アイテム間にカンマも追加されません。`Flux<MyEntity>`を手動で`Flux<String>`にマップして、ラップする`[`と`]`、アイテム間のカンマを追加すべきでしょうか？

### コメント 5 by rstoyanchev

**作成日**: 2022-05-17

`setStreamingMediaTypes`のJavadocを見ると、主にアイテムごとのフラッシュ（定期的に発行されるイベントストリーム用）と最後に1回のフラッシュ（連続ストリーム用）に関するものです。

もし[ストリーミングセクション](https://github.com/spring-projects/spring-framework/blob/874077d16ec126ca19d4b9fbb4157cfdc4eac382/spring-web/src/main/java/org/springframework/http/codec/json/AbstractJackson2Encoder.java#L155-L183)にいて、メディアタイプが「application/json」の場合（つまり、明示的にストリーミングメディアタイプとして設定されている場合）、有効なJSONを生成するために開始と終了の角括弧を追加するだけでよいかもしれません。

また、1より大きい一定の間隔でフラッシュするように切り替えることもできます（または、単に基礎となるサーバーバッファに任せる）。これは、連続的な書き込みを意味するメディアタイプであり、明示的なフラッシュは必要ないことがわかっているためです。その場合、非ストリーミングセクションを完全に削除し、デフォルトでこれを行うことも検討しています。そうすれば、`Flux`アイテムは常に到着時に書き込まれ、ストリーミングメディアタイプと非ストリーミングメディアタイプの唯一の違いはフラッシュになります。

### コメント 6 by hu553in

**作成日**: 2023-07-11

@rstoyanchev 現在、この動作を古い方法にオーバーライドする方法はありますか？

Spring WebFlux Kotlinの`Flow`エンドポイントを一時的に設定して、`Content-Type: application/json`にし、書き込む前にリストに収集する必要があります...

フロントエンドアプリが現時点でストリームを処理できないためです。

### コメント 7 by bclozel

**作成日**: 2023-07-11

@hu553in この課題は逆方向に関するものです：クライアントから単一のJSONドキュメントとしてすべての要素をバッファリングする前に送信することを避けることです。WebFluxのサーバー側を使用していて、`application/json`コンテンツタイプを使用している場合、データはクライアントにストリームされるべきではありません。問題を説明し、使用方法を示す新しいStackOverflowの質問を作成してみてはいかがでしょうか？

### コメント 8 by hu553in

**作成日**: 2023-07-11

@bclozel [完了しました](https://stackoverflow.com/questions/76663504/how-to-return-kotlin-flow-as-non-streaming-json-data-using-content-type-applica)。ありがとうございます... :)

確認していただけると嬉しいです。もしかしたら簡単な答えがあるかもしれません。これはそれほど複雑な課題ではないと思います。
