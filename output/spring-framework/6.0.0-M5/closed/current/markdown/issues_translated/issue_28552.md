# 末尾スラッシュマッチを非推奨にし、デフォルト値をtrueからfalseに変更

**課題番号**: #28552

**状態**: closed | **作成者**: vpavic | **作成日**: 2022-06-01

**ラベル**: in: web, type: enhancement

**URL**: https://github.com/spring-projects/spring-framework/issues/28552

**関連リンク**:
- Commits:
  - [d96b4a0](https://github.com/spring-projects/spring-framework/commit/d96b4a046342a5d886eeb967c05f8b7f95b6dfb1)
  - [4bff95a](https://github.com/spring-projects/spring-framework/commit/4bff95a18017b7a9f603315c606e8f31e74bd658)
  - [0098f29](https://github.com/spring-projects/spring-framework/commit/0098f2931adaa919ddfe66eda2ef620036e7044a)
  - [b312eca](https://github.com/spring-projects/spring-framework/commit/b312eca39177cf9bd588c52c3b56ca42b4f75271)
  - [a81ba68](https://github.com/spring-projects/spring-framework/commit/a81ba68da19efc6f09fe70497f4cf5d4d6c3b190)
  - [93b343f](https://github.com/spring-projects/spring-framework/commit/93b343fbd605d05e3b209bd69f011022eccf72ec)

## 内容

> 末尾スラッシュの有無に関わらずURLにマッチするかどうか。有効にすると、`"/users"`にマップされたメソッドは`"/users/"`にもマッチします。

> デフォルト値は`true`です。

この動作は長い間Springに存在していますが、（他の選択と組み合わせると）セキュリティ脆弱性の形で容易に結果をもたらす可能性のある曖昧さを導入します。次の例を考えてみてください：

```java
@SpringBootApplication
@RestController
public class SampleApplication {

    public static void main(String[] args) {
        SpringApplication.run(SampleApplication.class, args);
    }

    @GetMapping("/resources")
    String resources() {
        return "Hello from /resources";
    }

    @GetMapping("/resources/{id}")
    String resourceById(@PathVariable Long id) {
        return "Hello from /resources/" + id;
    }

    @Bean
    SecurityFilterChain filterChain(HttpSecurity httpSecurity) throws Exception {
        return httpSecurity
                .authorizeHttpRequests(requests -> {
                    requests.antMatchers("/resources").hasRole("admin");
                    requests.antMatchers("/resources/**").hasRole("user");
                    requests.anyRequest().denyAll();
                })
                .httpBasic(Customizer.withDefaults())
                .build();
    }

}
```

```properties
spring.security.user.password=password
spring.security.user.roles=user
```

デフォルトユーザー（`user`ロールを持つ）は`GET /resources`で`403`を受け取りますが、`GET /resources/`を発行することで保護を回避できます。これは、末尾スラッシュマッチを無効にすると不可能になります。

`antMatchers`の代わりに`mvcMatchers`を使用していればこの課題を防げたことは認識していますが、`antMatchers`に依存する多くの設定が存在し、時には他の理由で`antMatchers`の方が単に適していることもあるという事実は変わりません。

また、私は個人的に末尾スラッシュマッチを有効にすることの実質的な利点はほとんどないと考えています。なぜなら：
- アプリケーションがサーバーサイド生成ビューをレンダリングする場合、ナビゲーションはいずれにせよハイパーリンクを使用して確立されます
- アプリケーションがAPIを公開する場合、リクエストがAPIドキュメントと整合していることが期待されます

アプリケーションが本当に両方のリクエストに応答する必要がある場合、アプリケーション全体の曖昧なリクエストマッピングの代わりにリダイレクトを設定する方が良い解決策だと主張します。

`6.0`でこの変更を検討してください。

## コメント

### コメント 1 by rstoyanchev

**作成日**: 2022-06-08

ほとんどのユーザーは、末尾スラッシュが違いを生まないことを期待すると思います。その観点から、デフォルトは不合理ではなく、HATEOASスタイルのナビゲーションやAPIガイダンスだけでなく、単にどこかでURLを手動で入力する場合もあります。

デフォルトを変更すると、多くのユーザーがそれを元に戻そうとするので、全体的にSpring SecurityをSpring MVCと`mvcMatchers`を通じて整合させる必要性を回避するのは困難です。これはより安全なデフォルトだと主張できますが、これはSpring Securityと一緒に使用された場合にのみ適用されます。それ自体では安全ではありません。

リダイレクトの設定については、プロキシのように外部で、つまりSpring SecurityとSpring MVCの前の別のレベルで問題を解決するという意味でしょうか？その方向性にはより興味がありますが、推奨事項としてしかできず、この課題とは独立してそのような推奨を行うことができます。

### コメント 2 by vpavic

**作成日**: 2022-06-09

> その観点から、デフォルトは不合理ではなく、HATEOASスタイルのナビゲーションやAPIガイダンスだけでなく、単にどこかでURLを手動で入力する場合もあります。

_URLを手動で入力する_というのは、Webアプリ（APIではない）の場合にのみ実際の論拠として見えます。そして、そこでも、ユーザーが直接入力する可能性のあるアプリケーションへのエントリポイントと見なされる少数の選択されたURLに対してのみ潜在的に有用です。

> これはより安全なデフォルトだと主張できますが、これはSpring Securityと一緒に使用された場合にのみ適用されます。それ自体では安全ではありません。

この部分には強く反対します - Spring Securityが行うことは特別でもユニークでもありません。他のJavaフィルターベースのセキュリティフレームワーク（例えばApache Shiro）や、Springアプリケーションの前に配置された外部コンポーネントでセキュリティ（認可）を適用することで、同じ種類のリスクに遭遇する可能性があります。結局のところ、高いレベルで、概念的にはこれらすべてが同じアプローチを取ります。

> リダイレクトの設定については、プロキシのように外部で、つまりSpring SecurityとSpring MVCの前の別のレベルで問題を解決するという意味でしょうか？

プロキシで外部的に、または[Tuckey UrlRewriteFilter](https://www.tuckey.org/urlrewrite/)のようなものを使用するか、必要な場所にリダイレクトを追加するために`ViewControllerRegistry::addRedirectViewController`を使用することもできます。

私がSpringで見たいのは、曖昧でないデフォルトであり、したがって悪用されにくいものです。`@GetMapping("/api/resources")`でアノテーションされたハンドラーを見たとき、明示的に追加の（曖昧な）動作をオプトインしない限り、見たものだけに本当にマップされることです。この変更と#23915を合わせると、それが実現されます。

### コメント 3 by rstoyanchev

**作成日**: 2022-06-10

必ずしも異議を唱えているわけではありません。単に、末尾スラッシュ自体は安全ではないという点を指摘しているだけです。URLも解釈するプロキシやフィルターと組み合わせた場合にのみ問題になり、より一般的には違いがある可能性があり、それは両方向に行く可能性があります。

とはいえ、これも時間をかけて見てきた理由であり、URLパスはできるだけそのまま放置し、できるだけ正規化を避けるべきだということです。これがフレームワークが違いを最小限に抑え、自然に整合する唯一の方法です。これも、`PathPatternParser`がマッピングにマッチさせるためにフルパスをデコードしないように設計された理由です。`AntPathMatcher`とは異なり、サフィックスパターンさえサポートしていません。

いずれにせよ、ここで本当に大きな違いを生み出す唯一の方法は、trailingSlashオプションを完全に非推奨にし、プロキシやフィルターを使用してリダイレクトするような代替ソリューションを奨励することだと思います。それにより、正確にどこでそれを行いたいかについてより正確になることが強制され、セキュリティ決定の前に行うことができます。そうでなければ、Webフレームワークとセキュリティフレームワーク間の不一致の可能性は残ります。デフォルトを単に切り替えるだけでは、それについて再び考えることなく簡単に元に戻すことができます。

これは6.0の可能性として議論します。

### コメント 4 by vpavic

**作成日**: 2022-06-10

> いずれにせよ、ここで本当に大きな違いを生み出す唯一の方法は、trailingSlashオプションを完全に非推奨にし、プロキシやフィルターを使用してリダイレクトするような代替ソリューションを奨励することだと思います。

それはさらに良いと思います。フィードバックありがとうございます。

### コメント 5 by rstoyanchev

**作成日**: 2022-06-21

**チームの決定：** これを進めます。これは、5.2および5.3で行ったサフィックスパターンマッチング、パスセグメントのトリミング、パスのデコードなど、他の様々なパスマッチングの変更と整合します。パスマッチングをより透明で明示的にします。

### コメント 6 by wilkinsona

**作成日**: 2022-06-21

この非推奨の一部としてデフォルトがfalseに変更されますか？

### コメント 7 by rstoyanchev

**作成日**: 2022-06-21

はい、そう考えています。そして、使用を停止するためには設定する必要があるため、そうしなければならないでしょう。サフィックスパターンマッチングでも同じ課題がありました。

### コメント 8 by rstoyanchev

**作成日**: 2022-06-29

末尾スラッシュオプションは現在非推奨となり、該当するすべての場所で`false`に設定されています。この変更は主にアノテーション付きコントローラーに適用されます。`SimpleUrlHandlerMapping`は、実際にはデフォルトですでに`false`に設定されていることがわかりました。それにもかかわらず、全体で非推奨となり、最終的には削除されます。

### コメント 9 by bclozel

**作成日**: 2022-07-01

コードを閲覧していてこれを見つけました@rstoyanchev：

https://github.com/spring-projects/spring-framework/blob/50240bb609b6441390d436005a7f2e7a4cdf5454/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/RequestMappingHandlerMapping.java#L85

この値も変更すべきでしょうか？

### コメント 10 by rstoyanchev

**作成日**: 2022-07-01

そうですね、そのようです。

### コメント 11 by MartinHaeusler

**作成日**: 2022-12-02

この小さなスタントは、純粋なフラストレーションで404課題を見つめる10時間以上の人間時間を費やしました。セキュリティフィルターチェーン、サーブレット、すべてをデバッグしました（素晴らしい楽しみでした！） - パスマッチャーに到達するまで、パターン（およびそのパスプレースホルダー）と提供されたパス間の唯一の違いが末尾スラッシュだけであることが明らかになりました。これは小規模アプリケーションでは明白かもしれませんが、私たちには300以上のエンドポイントマッピングがあります。長い移行ノートのどこかに`404`という小さなフレーズが表示されていれば、見つけることができたでしょう。

### コメント 12 by bclozel

**作成日**: 2022-12-02

@MartinHaeusler 申し訳ございません。同じ課題を他の開発者にも避けられるようにドキュメントを改善できるかもしれません。この作業中にどのドキュメントを見ていましたか？

### コメント 13 by MartinHaeusler

**作成日**: 2022-12-02

@bclozel 私たちはこれを見ていました：

https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-3.0-Migration-Guide

しかし、Spring Boot（すべてのモジュールを含む）がどれほど大きいかを考えると、このドキュメントのどの部分が特定のアプリケーションに関連しているかを判断するのは難しいです。「Spring Boot 3 404」をGoogleで検索する時間を費やしましたが、検索結果は最新バージョンに固有のものを生成しませんでした。この時点まで、一部のクライアントがエンドポイントに末尾スラッシュを送信していることさえ**認識していませんでした**。それは単に「たまたま動作していた」だけです。そのため、末尾スラッシュのセクションは特に注目を集めませんでした。移行ガイドを検索しやすくする（つまり「Xを更新しない場合、エラーYを受け取ります」）と素晴らしかったでしょう。移行ガイドに「アプリケーションがこの動作に依存していた場合、HTTP 404エラーを受け取ります」という言及があれば、すぐに見つけられたでしょう... 悪い気持ちはありません。私たちは現在それを認識しており、先に進むことができます。

### コメント 14 by bclozel

**作成日**: 2022-12-02

@MartinHaeusler [Spring Boot移行ガイドの専用セクション](https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-3.0-Migration-Guide#spring-mvc-and-webflux-url-matching-changes)に「HTTP 404エラー」についての簡単な言及を追加しました。これが他の人の助けになることを願っています。ご指摘ありがとうございました。

### コメント 15 by armlesshobo

**作成日**: 2022-12-20

デフォルトで末尾スラッシュをトリミングすることについての検討はありますか？

### コメント 16 by kdebski85

**作成日**: 2022-12-29

@bclozel 移行ガイドはSpringMVCだけでなく、SpingFluxの回避策も提供すべきです。

次のようなもの：

```java
@Configuration
class WebConfiguration implements WebFluxConfigurer {

    @Override
    public void configurePathMatching(PathMatchConfigurer configurer) {
        configurer.setUseTrailingSlashMatch(true);
    }
}
```

### コメント 17 by philwebb

**作成日**: 2022-12-29

@kdebski85 提案ありがとうございます。Wikiを更新しました。

### コメント 18 by kdebski85

**作成日**: 2022-12-30

@philwebb `authorizeExchange`と`pathMatchers`を使用する場合、WebFluxConfigurerによる回避策が機能しないことがわかりました。

この課題についてhttps://github.com/spring-projects/spring-framework/issues/29755を作成しました。

### コメント 19 by lpandzic

**作成日**: 2023-01-31

これは大規模な観点からかなり問題があるように思えます。

多くのSpring BootアプリケーションがAPI開発者がほとんど、またはまったくコントロールできない多くの異なる顧客に提供されるAPIであることを考えてください。

これがSpring Boot 3以前で機能していたため、これらの顧客のいずれかがレガシー動作を使用していた場合、アプリケーション開発者は基本的にこのレガシー動作を無期限にサポートすることを余儀なくされる不可能な状況に置かれます。無期限と言っているのは、すべての顧客に表面的または純粋主義的な理由で見えるものについてコードで修正するよう説得できる可能性は極めて低いと思うからです。

この変更に必ずしも反対しているわけではありませんが、上記で説明した状況のために、Spring Frameworkチームは多くの批判を受けることになると予想しています。これは開発者を不可能な状況に置き、最初は検出が難しく、多くのフラストレーションを引き起こす可能性があります。

Infobipでは、すべてのパブリックAPIに対してこの変更を複製せずに修正する場所を知っていますが、誰もがそれほど幸運ではないかもしれません。

### コメント 20 by dkoding

**作成日**: 2023-02-22

この素晴らしい動きは、私たちのチームに何百時間もの人的時間を費やさせました。ありがとうございました。
