# アノテーションが付与された要素がリフレクションヒントを必要とすることを示すメタアノテーションを導入

**課題番号**: #28469

**状態**: closed | **作成者**: snicoll | **作成日**: 2022-05-17

**ラベル**: type: enhancement, theme: aot

**URL**: https://github.com/spring-projects/spring-framework/issues/28469

**関連リンク**:
- Commits:
  - [255a52b](https://github.com/spring-projects/spring-framework/commit/255a52bc7a5f10a1f142f45e4ef7118f241314aa)
  - [4cca190](https://github.com/spring-projects/spring-framework/commit/4cca190aad3cf643c765f39655432e0ebd00549e)

## 内容

私たちは現在、持続可能な方法で多数のヒントを移植し、ポートフォリオにある共通パターンのための専用コードを書く必要を回避する段階にいます。

そのようなシンプルなパターンの1つは次のとおりです：

```java
@EventListener
public void onContextRefresh(ContextRefreshedEvent event) { ... }
```

`@EventListener`を処理する内部実装は、リフレクション経由でメソッドを呼び出すラッパーを作成するため、制限された環境（ネイティブイメージ）で動作するには呼び出しヒントが必要です。

より複雑なパターンは次のようになります：

```java
@GetMapping("/dtos/{id}")
public MyDto findById(String id) { ... }
```

この場合、`findById`メソッドがリフレクションで呼び出されるだけでなく、`MyDto`が何らかのコンバーターを使用してシリアライズされる可能性が高く、したがって追加のヒントが必要になります。

専用の`BeanRegistrationAotProcessor`や`BeanFactoryInitializationAotProcessor`を持つのではなく、特定のアノテーションの存在をチェックする汎用的なものを構築できます。その後、リフレクションが必要であることがわかっているアノテーションにアノテーションを付けて、半自動的に処理されるようにすることができます。

```java
@Target({ElementType.METHOD, ElementType.ANNOTATION_TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Reflective
public @interface EventListener { ... }
``` 

`@Reflective`は使用する戦略を取ることができます（`@Conditional`と同様に）。これにより、MVCのユースケースのようなより細かいアルゴリズムの実装に役立ちます。

## コメント

### コメント 1 by snicoll

**作成日**: 2022-05-17

1つ言及すべきことは、このメタアノテーションの追加は一時的なものにできるということです。基盤となるインフラストラクチャが完全にAhead-of-Timeで解決され、したがってAOTベースのコンテキストのためのリフレクションの必要性がなくなれば、メタアノテーションは単に削除できます。
