# @HttpExchangeのurl属性でプロパティプレースホルダーをサポート

**課題番号**: #28492

**状態**: closed | **作成者**: xuan | **作成日**: 2022-05-20

**ラベル**: in: web, type: enhancement

**URL**: https://github.com/spring-projects/spring-framework/issues/28492

**関連リンク**:
- Commits:
  - [2a2fba6](https://github.com/spring-projects/spring-framework/commit/2a2fba6a37666b41205565b7d1a804373a6635d2)

## 内容

**影響バージョン:** 6.0.0-SNAPSHOT

---

Spring Teamの皆さん、こんにちは。

`application.yaml`で定義されたプロパティを`@HttpExchange`、`@GetExchange`、`@PostExchange`で参照できる機能を追加していただけますか？

現在、アノテーション内でURLをハードコードする必要があります：

```java
@HttpExchange(url = "/multitenant/public/api")
public interface CumulusRepository {

    @GetExchange("/get_stuff")
    Cumulus getCumulusAlerts(@RequestHeader Map<String, String> headers);

    @PostExchange("/getAccessToken")
    Token getAccessToken(@RequestBody String credential);
}
```

しかし、URLを`application.yaml`で定義し、次のようにアノテーションで参照したいです：

```java
@HttpExchange(url = "${cumulus.baseUrl}")
public interface CumulusRepository {

    @GetExchange("${cumulus.alertUrl}")
    Cumulus getCumulusAlerts(@RequestHeader Map<String, String> headers);

    @PostExchange("${cumulus.tokenUrl}")
    Token getAccessToken(@RequestBody String credential);
}
```

## コメント

### コメント 1 by jcthalys

**作成日**: 2022-12-02

これは私にはまだ動作していません：

```java 
// spring boot 3.0.0とframework 6.0.2を使用
@SpringBootApplication
public class HttpInterfaceApplication {

	public static void main(String[] args) {
		SpringApplication.run(HttpInterfaceApplication.class, args);
	}

	@Bean
	ApplicationListener<ApplicationReadyEvent> ready(GoogleClient googleClient) {
		return event -> {
			String googlePage = googleClient.getGooglePage();
			System.out.println(googlePage);
		};
	}

	@Bean
	GoogleClient googleClient(HttpServiceProxyFactory factory) {
		return factory.createClient(GoogleClient.class);
	}

	@Bean
	HttpServiceProxyFactory getHttpServiceProxyFactory(WebClient.Builder builder) {
		return HttpServiceProxyFactory.builder()
				.clientAdapter(WebClientAdapter.forClient(builder.build())).build();
	}
}

@HttpExchange(url = "${google.url}")
interface GoogleClient {
	@GetExchange
	String getGooglePage();
}
```

エラー：

```log
java.lang.IllegalArgumentException: Map has no value for 'google.url'
	at org.springframework.web.util.UriComponents$MapTemplateVariables.getValue(UriComponents.java:348) ~[spring-web-6.0.2.jar:6.0.2]
	at org.springframework.web.util.UriComponents.expandUriComponent(UriComponents.java:263) ~[spring-web-6.0.2.jar:6.0.2]
	at org.springframework.web.util.HierarchicalUriComponents$FullPathComponent.expand(HierarchicalUriComponents.java:921) ~[spring-web-6.0.2.jar:6.0.2]
	at org.springframework.web.util.HierarchicalUriComponents.expandInternal(HierarchicalUriComponents.java:439) ~[spring-web-6.0.2.jar:6.0.2]
	at org.springframework.web.util.HierarchicalUriComponents.expandInternal(HierarchicalUriComponents.java:52) ~[spring-web-6.0.2.jar:6.0.2]
	at org.springframework.web.util.UriComponents.expand(UriComponents.java:161) ~[spring-web-6.0.2.jar:6.0.2]
	at org.springframework.web.util.DefaultUriBuilderFactory$DefaultUriBuilder.build(DefaultUriBuilderFactory.java:391) ~[spring-web-6.0.2.jar:6.0.2]
	at org.springframework.web.util.DefaultUriBuilderFactory.expand(DefaultUriBuilderFactory.java:149) ~[spring-web-6.0.2.jar:6.0.2]
	at org.springframework.web.reactive.function.client.DefaultWebClient$DefaultRequestBodyUriSpec.uri(DefaultWebClient.java:228) ~[spring-webflux-6.0.2.jar:6.0.2]
	at org.springframework.web.reactive.function.client.DefaultWebClient$DefaultRequestBodyUriSpec.uri(DefaultWebClient.java:189) ~[spring-webflux-6.0.2.jar:6.0.2]
	at org.springframework.web.reactive.function.client.support.WebClientAdapter.newRequest(WebClientAdapter.java:105) ~[spring-webflux-6.0.2.jar:6.0.2]
	at org.springframework.web.reactive.function.client.support.WebClientAdapter.requestToBody(WebClientAdapter.java:69) ~[spring-webflux-6.0.2.jar:6.0.2]
	at org.springframework.web.service.invoker.HttpServiceMethod$ResponseFunction.lambda$initBodyFunction$5(HttpServiceMethod.java:378) ~[spring-web-6.0.2.jar:6.0.2]
	at org.springframework.web.service.invoker.HttpServiceMethod$ResponseFunction.execute(HttpServiceMethod.java:288) ~[spring-web-6.0.2.jar:6.0.2]
	at org.springframework.web.service.invoker.HttpServiceMethod.invoke(HttpServiceMethod.java:105) ~[spring-web-6.0.2.jar:6.0.2]
	at org.springframework.web.service.invoker.HttpServiceProxyFactory$HttpServiceMethodInterceptor.invoke(HttpServiceProxyFactory.java:271) ~[spring-web-6.0.2.jar:6.0.2]
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:184) ~[spring-aop-6.0.2.jar:6.0.2]
	at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:218) ~[spring-aop-6.0.2.jar:6.0.2]

```

URLを直接使用すると正常に動作します。

### コメント 2 by renatomrcosta

**作成日**: 2022-12-02

> これは私にはまだ動作していません：

私も同じ課題に遭遇し、URL属性が`application properties`を考慮するのか、それともURIプレースホルダーだけを考慮するのかを明確にするための手がかりを見つけました。

このエラーは、プレースホルダー付きのアプリケーションプロパティが全く考慮されていないことを示しています。試してみると、それは単にパスとして考慮されます（`"/v1/api/customer/{customerId}"`を呼び出す場合のように）。Javaの`$`記号やKotlinの`\$`は解析されませんでした。

```kotlin
@HttpExchange(url = "{httpbin}") // ここでは単一の名前を選びました。単純に中括弧を削除して$を戻すだけでは動作しませんが、テストに使うには十分簡単です。
interface HttpBinClient {
    @GetExchange("/anything")
    fun anything(@PathVariable("httpbin") httpbin: String): Mono<String>
}
```

（動作例のあるリポジトリはこちら：[LINK](https://github.com/renatomrcosta/springboot3releaseplayground/blob/spring-issue-28492/src/main/kotlin/com/xunfos/springboot3releaseplayground/Springboot3releaseplaygroundApplication.kt)）

では、この場合：URLやその他の属性がアプリケーションプロパティでパラメータ化されることが本当に意図されているのでしょうか？もしそうなら、このチケットは完了としてクローズされるべきではありません。

そうでなければ@jcthalys、当面の間、より冗長なアプローチとして、必要なhttpProxyFactoryごとにbaseUrlを設定したwebClientを提供し、アノテーションレベルでURLプロパティを設定しないことをお勧めします。私も当面はそのアプローチを取るつもりです。
