*このドキュメントは生成AI(Claude Sonnet 4.5)によって2026年1月6日に生成されました。*

## 課題概要

`ClassNameGenerator`クラスの`generateClassName`メソッドが2つのバリアント（`Class<?>`版と`String`版）を持ち、それぞれ異なる動作をするため、曖昧で混乱を招くという問題を解決する改善です。

**背景説明**:
- **ClassNameGenerator**: AOT（Ahead-Of-Time）コンパイル時に生成されるクラスの名前を自動生成するユーティリティクラス
- **AOT**: アプリケーション起動前にコードを事前生成する仕組み（GraalVMネイティブイメージなど）
- **パッケージの可視性**: Javaのアクセス制御で、同じパッケージ内のクラスからアクセス可能

**問題の詳細**:
`ClassNameGenerator`に2つの似た名前のメソッドが存在し、動作が大きく異なります：

```java
// バリアント1: Class<?>を渡す
ClassName first = generator.generateClassName(
    java.io.InputStream.class, "bytes");
// 結果: java.io.InputStream__Bytes
// → 同じパッケージに生成（可視性問題の回避可能）

// バリアント2: Stringを渡す
ClassName second = generator.generateClassName(
    "java.io.InputStream", "bytes");
// 結果: __.JavaIoInputStream__Bytes
// → 特殊な__パッケージに生成（可視性問題が発生しうる）
```

**混乱の原因**:
1. **名前が同じ**: メソッド名が全く同じで、引数の型でしか区別できない
2. **動作の違い**: パッケージの配置場所が大きく異なる
3. **ドキュメント不足**: Javadocでこの違いが明確に説明されていない
4. **可視性問題**: `String`バリアントは可視性問題を回避しにくい設計
5. **廃止された参照**: ドキュメントが廃止された`GeneratedClassName`を参照

## 原因

AOTプロトタイピング中に、特定のクラスにリンクできない場合（例: Bean登録のコード生成）のために`String`バリアントが追加されました。

しかし、以下が不十分でした：
- メソッド名とドキュメントで用途の違いを明確化
- `__`パッケージの使用意図の説明
- より適切な設計の検討（別パッケージへの配置など）

## 対応方針

段階的に問題を解決しました：

**フェーズ1: String版の削除**

[4bd33cb](https://github.com/spring-projects/spring-framework/commit/4bd33cb6e0659df2cd0b9fa04feea8fd77e5a16d)で`String`バリアントを削除：

```java
// 削除されたメソッド
@Deprecated
public ClassName generateClassName(String target, String feature) {
    // __パッケージに生成していた
}
```

**削除の根拠**:
- `BeanRegistrationsAotContribution`でのみ使用されていた
- `@SpringBootApplication`クラスと同じパッケージにBean登録コードを生成することで代替可能
- より明確な設計に変更

**フェーズ2: Javadocの改善**

[63fae8c](https://github.com/spring-projects/spring-framework/commit/63fae8c5a7ea21e4ff59ee094cc4541c048e8e54)で残った`Class<?>`版のドキュメントを改善：

```java
/**
 * 指定されたターゲットクラスと機能名から、生成されるクラスの名前を生成します。
 * 
 * @param target 生成されるコードが関連するターゲットクラス
 * @param feature クラス名に含める機能を説明する文字列
 * @return 生成されるクラス名（ターゲットと同じパッケージ）
 */
public ClassName generateClassName(Class<?> target, String feature) {
    // ...
}
```

**改善後の使用例**:
```java
// 明確な動作
ClassName name = generator.generateClassName(UserService.class, "Proxy");
// 結果: com.example.UserService__Proxy
// UserServiceと同じパッケージに生成されるため、可視性問題なし
```

**メリット**:
- メソッドの動作が明確に
- 曖昧さの排除
- 可視性問題の回避が容易
- より保守しやすいAPI設計
