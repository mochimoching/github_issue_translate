*このドキュメントは生成AI(Claude Sonnet 4.5)によって2026年1月6日に生成されました。*

## 課題概要

`BeanDefinitionPropertiesCodeGenerator`が生成するAOTコードで、単一の推測されたinit/destroyメソッドの場合に、不要な`setInitMethodNames()`/`setDestroyMethodNames()`呼び出しを生成しないよう改善するタスクです。

**背景説明**:
- **BeanDefinitionPropertiesCodeGenerator**: Bean定義のプロパティ設定コードをAOT時に生成するクラス
- **initメソッド**: Beanの初期化時に呼び出されるメソッド（例: `afterPropertiesSet()`）
- **destroyメソッド**: Beanの破棄時に呼び出されるメソッド（例: `destroy()`）
- **INFER_METHOD**: メソッド名を自動推測することを示す特殊な定数（`"(inferred)"`）

**問題の詳細**:
現状のコード生成：
```java
// 生成されるBean登録コード（改善前）
RootBeanDefinition beanDefinition = new RootBeanDefinition(MyService.class);
beanDefinition.setInitMethodNames("(inferred)");  // 不要
beanDefinition.setDestroyMethodNames("(inferred)");  // 不要
beanFactory.registerBeanDefinition("myService", beanDefinition);
```

**課題**:
- `INFER_METHOD`（`"(inferred)"`）のみが指定されている場合、これはデフォルト動作と同じ
- 明示的に設定する必要がない
- コードが冗長で見栄えが悪い

**期待される動作**:
```java
// 改善後の生成コード
RootBeanDefinition beanDefinition = new RootBeanDefinition(MyService.class);
// setInitMethodNames/setDestroyMethodNamesの呼び出しなし（デフォルト動作を使用）
beanFactory.registerBeanDefinition("myService", beanDefinition);
```

## 原因

`BeanDefinitionPropertiesCodeGenerator`の実装が、`INFER_METHOD`を特別扱いせず、すべてのinit/destroyメソッド設定を生成していました。

しかし、`INFER_METHOD`は以下を意味します：
- Springが自動的にメソッド名を推測する
- これはBean定義のデフォルト動作
- 明示的に設定する必要がない

## 対応方針

[9a9c3ea](https://github.com/spring-projects/spring-framework/commit/9a9c3ea00e2a955c06452d1e28d092594cca53a8)のコミットで実装されました。

**実装内容**:

`BeanDefinitionPropertiesCodeGenerator`を修正し、`INFER_METHOD`のみの場合はコード生成をスキップ：

```java
public class BeanDefinitionPropertiesCodeGenerator {
    
    public void generateCode(RootBeanDefinition beanDefinition, CodeBlock.Builder code) {
        // initメソッドの処理
        String[] initMethodNames = beanDefinition.getInitMethodNames();
        if (shouldGenerateInitMethodNames(initMethodNames)) {
            code.addStatement("$L.setInitMethodNames($L)", 
                BEAN_DEFINITION_VARIABLE, 
                toStringArray(initMethodNames));
        }
        
        // destroyメソッドの処理
        String[] destroyMethodNames = beanDefinition.getDestroyMethodNames();
        if (shouldGenerateDestroyMethodNames(destroyMethodNames)) {
            code.addStatement("$L.setDestroyMethodNames($L)", 
                BEAN_DEFINITION_VARIABLE, 
                toStringArray(destroyMethodNames));
        }
    }
    
    private boolean shouldGenerateInitMethodNames(String[] methodNames) {
        // 単一のINFER_METHODのみの場合はfalse
        if (methodNames == null || methodNames.length == 0) {
            return false;
        }
        if (methodNames.length == 1 && 
            AbstractBeanDefinition.INFER_METHOD.equals(methodNames[0])) {
            return false;  // デフォルト動作なので生成不要
        }
        return true;
    }
    
    private boolean shouldGenerateDestroyMethodNames(String[] methodNames) {
        // initと同様のロジック
        // ...
    }
}
```

**改善結果の比較**:

**ケース1: INFER_METHODのみ（最も一般的）**:
```java
// 改善前
beanDefinition.setInitMethodNames("(inferred)");
beanDefinition.setDestroyMethodNames("(inferred)");

// 改善後（コード生成なし）
// （デフォルト動作を使用）
```

**ケース2: 明示的なメソッド名**:
```java
// 改善前・改善後ともに同じ（必要なコード）
beanDefinition.setInitMethodNames("init", "setup");
beanDefinition.setDestroyMethodNames("cleanup");
```

**ケース3: 複数のメソッド名（INFERを含む）**:
```java
// 改善前・改善後ともに同じ（必要なコード）
beanDefinition.setInitMethodNames("(inferred)", "customInit");
```

**具体例**（実際の生成コード）:
```java
// 典型的なBean定義
@Configuration
public class MyConfig {
    @Bean
    public MyService myService() {
        return new MyService();
    }
}

// 改善前のAOT生成コード
RootBeanDefinition bd = new RootBeanDefinition(MyService.class);
bd.setInitMethodNames("(inferred)");     // 冗長
bd.setDestroyMethodNames("(inferred)");  // 冗長
bd.setInstanceSupplier(() -> context.getBean(MyConfig.class).myService());
registry.registerBeanDefinition("myService", bd);

// 改善後のAOT生成コード
RootBeanDefinition bd = new RootBeanDefinition(MyService.class);
// setInitMethodNames/setDestroyMethodNamesの呼び出しなし
bd.setInstanceSupplier(() -> context.getBean(MyConfig.class).myService());
registry.registerBeanDefinition("myService", bd);
```

**メリット**:
- 生成されるコードの簡潔化
- 可読性の向上
- 無駄なコード行の削減
- デフォルト動作の明確化
- 生成されるクラスファイルサイズのわずかな削減
