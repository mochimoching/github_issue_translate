*このドキュメントは生成AI(Claude Sonnet 4.5)によって2026年1月6日に生成されました。*

## 課題概要

`RuntimeHints`に登録されたヒント情報が、特定のユースケース（リフレクション呼び出しなど）に十分かどうかをチェックするための述語（Predicate）ユーティリティを導入する機能強化です。

**背景説明**:
- **RuntimeHints**: AOT/ネイティブイメージビルド時に、リフレクション/プロキシ/リソースのニーズを記述するAPI
- **述語（Predicate）**: 条件を満たすかどうかを判定する関数型インターフェース
- **MemberCategory**: クラスメンバー（メソッド、フィールドなど）のアクセスレベルを表すカテゴリ

**問題の詳細**:
実行時の単一の操作（例: メソッドのリフレクション呼び出し）は、複数の異なるヒントでカバーできます。

例：クラス`MyClass`の`myMethod`メソッドへのリフレクションイントロスペクションは、以下のいずれでもカバー可能：

```java
// パターン1: publicメソッドのイントロスペクション
hints.reflection().registerType(MyClass.class, 
    MemberCategory.INTROSPECT_PUBLIC_METHODS);

// パターン2: publicメソッドの呼び出し（イントロスペクションも含む）
hints.reflection().registerType(MyClass.class, 
    MemberCategory.INVOKE_PUBLIC_METHODS);

// パターン3: すべてのメソッドのイントロスペクション
hints.reflection().registerType(MyClass.class, 
    MemberCategory.INTROSPECT_DECLARED_METHODS);

// パターン4: すべてのメソッドの呼び出し
hints.reflection().registerType(MyClass.class, 
    MemberCategory.INVOKE_DECLARED_METHODS);

// パターン5: 特定メソッドへの直接ヒント
hints.reflection().registerMethod(
    MyClass.class.getMethod("myMethod"),
    ExecutableMode.INTROSPECT);
```

**課題**:
これらのヒント登録に対して、「特定の操作に十分なヒントが登録されているか？」をテストする方法がありませんでした。

テストで検証したいケース：
```java
// このヒントで MyClass#myMethod() を呼び出せるか？
RuntimeHints hints = ...;
// ヒントが十分かどうかをチェックしたい
```

## 原因

`RuntimeHints` APIが、ヒントの「登録」機能のみを提供しており、「検証」機能を提供していませんでした。

テストやツール（[#27981](https://github.com/spring-projects/spring-framework/issues/27981)）で、登録されたヒントが特定のユースケースに十分かどうかを判定するには：
- 複数の異なるヒントパターンを理解する必要がある
- カテゴリベースのヒントと個別ヒントの包含関係を考慮する必要がある
- この知識を各テストで重複して実装する必要があった

## 対応方針

以下のコミットで実装されました：

- [7f7f458](https://github.com/spring-projects/spring-framework/commit/7f7f458a5977ad51f6ba7cfbb3440e33b754d60b)
- [15b69a3](https://github.com/spring-projects/spring-framework/commit/15b69a3edec7a7f1dc166e3f07fa4b1cb54b0df9)
- [9c9b235](https://github.com/spring-projects/spring-framework/commit/9c9b2356cec4a74c685320c5b8b1b6eb283f9dc0)

**実装内容**:

`RuntimeHintsPredicates`静的ユーティリティクラスを導入：

```java
// 使用例: リフレクションヒントのテスト
@Test
void testReflectionHints() {
    RuntimeHints hints = new RuntimeHints();
    hints.reflection().registerType(MyClass.class, 
        MemberCategory.INVOKE_PUBLIC_METHODS);
    
    // メソッド呼び出しに十分なヒントがあるかチェック
    assertThat(RuntimeHintsPredicates.reflection()
        .onMethod(MyClass.class, "myMethod")
        .invoke())
        .accepts(hints);  // ✅ パス
}
```

**提供される述語**:

1. **リフレクション述語**:
```java
// 型のイントロスペクション
RuntimeHintsPredicates.reflection()
    .onType(MyClass.class)
    .test(hints);

// メソッド呼び出し
RuntimeHintsPredicates.reflection()
    .onMethod(MyClass.class, "methodName")
    .invoke()
    .test(hints);

// フィールドアクセス
RuntimeHintsPredicates.reflection()
    .onField(MyClass.class, "fieldName")
    .test(hints);

// コンストラクタ呼び出し
RuntimeHintsPredicates.reflection()
    .onConstructor(MyClass.class, parameterTypes)
    .invoke()
    .test(hints);
```

2. **リソース述語**:
```java
// リソースパターンマッチ
RuntimeHintsPredicates.resource()
    .forResource("META-INF/spring.factories")
    .test(hints);
```

3. **プロキシ述語**:
```java
// JDKプロキシ
RuntimeHintsPredicates.proxies()
    .forInterfaces(MyInterface.class)
    .test(hints);
```

**テストでの活用**:
```java
@Test
void shouldRegisterReflectionHints() {
    RuntimeHints hints = new RuntimeHints();
    new MyRuntimeHintsRegistrar().registerHints(hints, classLoader);
    
    // アサーション
    assertThat(RuntimeHintsPredicates.reflection()
        .onMethod(UserService.class, "findById", Long.class)
        .invoke())
        .accepts(hints);
    
    assertThat(RuntimeHintsPredicates.resource()
        .forResource("application.properties"))
        .accepts(hints);
}
```

**メリット**:
- ヒント検証ロジックの標準化
- テストの保守性向上
- カテゴリベースと個別ヒントの包含関係を自動判定
- ツールやフレームワークでの再利用が容易
- AssertJとの統合

**関連課題**: [#27981](https://github.com/spring-projects/spring-framework/issues/27981)
