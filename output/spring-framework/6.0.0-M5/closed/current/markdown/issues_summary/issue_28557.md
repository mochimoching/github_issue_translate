*このドキュメントは生成AI(Claude Sonnet 4.5)によって2026年1月6日に生成されました。*

## 課題概要

`BeanRegistrationAotContribution`から直接`BeanRegistrationCodeFragments`をカスタマイズできるようにする機能強化です。これにより、既存の`BeanRegistrationCodeFragmentsCustomizer`インターフェースが不要になります。

**背景説明**:
- **BeanRegistrationCodeFragments**: Bean登録コードの各部分（インスタンス生成、プロパティ設定など）を生成するためのコンポーネント
- **BeanRegistrationAotContribution**: AOT処理でBean登録をカスタマイズするための貢献クラス
- **BeanRegistrationCodeFragmentsCustomizer**: コードフラグメントをカスタマイズするための専用インターフェース
- **親/子コンテキスト**: Spring ApplicationContextの階層構造

**問題の詳細**:
現状では、Bean登録コードのカスタマイズに2つの異なるメカニズムが存在：

**パターン1**: `BeanRegistrationAotContribution`を使用：
```java
public class MyAotContribution implements BeanRegistrationAotContribution {
    @Override
    public void applyTo(GenerationContext context, BeanRegistrationCode code) {
        // Bean登録コードをカスタマイズ
        // しかしBeanRegistrationCodeFragmentsは直接カスタマイズできない
    }
}
```

**パターン2**: `BeanRegistrationCodeFragmentsCustomizer`を使用：
```java
public class MyCustomizer implements BeanRegistrationCodeFragmentsCustomizer {
    @Override
    public BeanRegistrationCodeFragments customize(
            RegisteredBean registeredBean, 
            BeanRegistrationCodeFragments codeFragments) {
        // コードフラグメントをカスタマイズ
        return new CustomCodeFragments(codeFragments);
    }
}
```

**課題**:
- 2つの似た機能を持つインターフェースが存在
- 親/子コンテキストサポートでは`BeanRegistrationAotContribution`から直接カスタマイズしたい
- `BeanRegistrationCodeFragmentsCustomizer`の存在意義が不明確
- APIの複雑化

## 原因

AOT API設計の初期段階で、コードフラグメントのカスタマイズを独立した懸念事項として分離しました。

しかし実装を進める中で、以下のことが判明：
- `BeanRegistrationAotContribution`で十分な柔軟性がある
- 専用の`Customizer`インターフェースは冗長
- 親/子コンテキストなどの高度なユースケースで不便

## 対応方針

以下のコミットで実装されました：

- [8d79ec0](https://github.com/spring-projects/spring-framework/commit/8d79ec0b67972f3bcd253b046c18fe22bc13d33a): 基本機能の追加
- [305055d](https://github.com/spring-projects/spring-framework/commit/305055d6b1a42c7795891b7b389936ed80270505): `Customizer`の削除

**実装内容**:

`BeanRegistrationAotContribution`を拡張し、コードフラグメントを直接カスタマイズ可能に：

```java
// 新しいAPI
public class MyAotContribution implements BeanRegistrationAotContribution {
    @Override
    public void applyTo(GenerationContext context, BeanRegistrationCode code) {
        // コードフラグメントを直接カスタマイズ
        code.customize(codeFragments -> 
            new CustomCodeFragments(codeFragments));
        
        // その他のカスタマイズ
        code.addInitializer(...);
    }
}
```

**親/子コンテキストでの使用例**:
```java
public class ChildContextAotContribution implements BeanRegistrationAotContribution {
    @Override
    public void applyTo(GenerationContext context, BeanRegistrationCode code) {
        // 親コンテキストからのBean取得をカスタマイズ
        code.customize(codeFragments -> {
            return new BeanRegistrationCodeFragments() {
                @Override
                public CodeBlock generateInstanceSupplierCode(...) {
                    // 親コンテキストから取得するコードを生成
                    return CodeBlock.of(
                        "() -> parentContext.getBean($T.class)", 
                        beanClass);
                }
                // 他のメソッドは委譲
            };
        });
    }
}
```

**削除されたAPI**:
```java
@Deprecated(forRemoval = true)
public interface BeanRegistrationCodeFragmentsCustomizer {
    BeanRegistrationCodeFragments customize(
        RegisteredBean registeredBean, 
        BeanRegistrationCodeFragments codeFragments);
}
```

**統合後のワークフロー**:
```
BeanRegistrationAotProcessor
    ↓
BeanRegistrationAotContribution
    ├─ カスタムコード生成
    ├─ イニシャライザー追加
    └─ コードフラグメントのカスタマイズ（新機能）
```

**メリット**:
- APIの簡素化（1つのインターフェースに統一）
- より一貫性のある設計
- 親/子コンテキストサポートの実装が容易
- すべてのカスタマイズを1か所で実装可能
- 学習コストの削減
