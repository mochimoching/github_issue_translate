*このドキュメントは生成AI(Claude Sonnet 4.5)によって2026年1月6日に生成されました。*

## 課題概要

`CompileWithTargetClassAccessClassLoader`クラスが`findResource()`メソッドを実装しておらず、単一リソースの検索ができないバグの修正です。

**背景説明**:
- **CompileWithTargetClassAccessClassLoader**: AOTテストで、コンパイル対象クラスに適切なアクセス権限を提供するカスタムClassLoader
- **ClassLoader**: Javaクラスやリソースを動的にロードする仕組み
- **findResource()**: 単一のリソースを検索するメソッド
- **findResources()**: 複数のリソース（同じ名前のものすべて）を検索するメソッド

**問題の詳細**:
`CompileWithTargetClassAccessClassLoader`の実装状況：
```java
public class CompileWithTargetClassAccessClassLoader extends ClassLoader {
    
    @Override
    protected Enumeration<URL> findResources(String name) throws IOException {
        // ✅ 実装済み
        return super.findResources(name);
    }
    
    @Override
    protected URL findResource(String name) {
        // ❌ 実装なし（オーバーライドされていない）
        // 親クラスのデフォルト実装が使われ、期待通りに動作しない
    }
}
```

**発生する問題**:
```java
// テストコード
ClassLoader classLoader = new CompileWithTargetClassAccessClassLoader(...);

// 複数リソースの検索は動作
Enumeration<URL> resources = classLoader.getResources("META-INF/spring.factories");
// ✅ 正しく動作

// 単一リソースの検索が失敗
URL resource = classLoader.getResource("application.properties");
// ❌ null が返される、または誤ったリソースが返される
```

## 原因

`CompileWithTargetClassAccessClassLoader`の実装時に、`findResources()`メソッドのみをオーバーライドし、`findResource()`メソッドのオーバーライドを見逃していました。

**ClassLoaderのリソース検索メソッド**:
```java
public abstract class ClassLoader {
    // 公開API: 単一リソース検索
    public URL getResource(String name) {
        // 内部でfindResource()を呼び出す
        return findResource(name);
    }
    
    // 公開API: 複数リソース検索
    public Enumeration<URL> getResources(String name) {
        // 内部でfindResources()を呼び出す
        return findResources(name);
    }
    
    // サブクラスでオーバーライドすべきメソッド
    protected URL findResource(String name) { ... }
    protected Enumeration<URL> findResources(String name) { ... }
}
```

カスタムClassLoaderでは、両方のメソッドをオーバーライドする必要がありますが、`findResource()`が漏れていました。

## 対応方針

[26944f3](https://github.com/spring-projects/spring-framework/commit/26944f3c8ef2f1d5e2a45ab0081556382e90e960)のコミットで修正されました。

**実装内容**:

`findResource()`メソッドを追加：

```java
public class CompileWithTargetClassAccessClassLoader extends ClassLoader {
    
    private final ClassLoader targetClassLoader;
    
    public CompileWithTargetClassAccessClassLoader(ClassLoader targetClassLoader) {
        super(targetClassLoader.getParent());
        this.targetClassLoader = targetClassLoader;
    }
    
    @Override
    protected URL findResource(String name) {
        // ターゲットClassLoaderから検索
        URL resource = this.targetClassLoader.getResource(name);
        if (resource != null) {
            return resource;
        }
        // 親ClassLoaderにフォールバック
        return super.findResource(name);
    }
    
    @Override
    protected Enumeration<URL> findResources(String name) throws IOException {
        // 既存の実装（変更なし）
        Enumeration<URL> resources = this.targetClassLoader.getResources(name);
        Enumeration<URL> parentResources = super.findResources(name);
        return new CompoundEnumeration<>(resources, parentResources);
    }
    
    // その他のメソッド
}
```

**修正後の動作**:

**単一リソースの検索**:
```java
// テストコード
ClassLoader classLoader = new CompileWithTargetClassAccessClassLoader(parentLoader);

// プロパティファイルの検索
URL resource = classLoader.getResource("application.properties");
// ✅ 正しいURLが返される

// Spring設定ファイルの検索
URL springConfig = classLoader.getResource("META-INF/spring.factories");
// ✅ 正しいURLが返される
```

**複数リソースの検索**（従来通り動作）:
```java
// すべてのマッチするリソースを検索
Enumeration<URL> resources = classLoader.getResources("META-INF/spring.factories");
while (resources.hasMoreElements()) {
    URL url = resources.nextElement();
    // ✅ すべてのマッチするリソースが返される
}
```

**使用例（AOTテスト）**:
```java
@Test
void testGeneratedCodeCanAccessResources() {
    // AOTで生成されたコードをコンパイル
    TestCompiler compiler = TestCompiler.forSystem()
        .withClassLoader(new CompileWithTargetClassAccessClassLoader(
            getClass().getClassLoader()));
    
    CompiledCode compiled = compiler.compile(generatedSourceFile);
    
    // コンパイルされたコードからリソースにアクセス
    Class<?> generatedClass = compiled.getClass("com.example.Generated");
    
    // リソース検索が正常に動作
    URL resource = generatedClass.getClassLoader()
        .getResource("META-INF/application.yml");  // ✅ 動作
    
    assertThat(resource).isNotNull();
}
```

**メリット**:
- 単一リソース検索の正常動作
- `ClassLoader`のコントラクトを完全に実装
- AOTテストでのリソースアクセスが確実に
- より堅牢なテストインフラ
