*このドキュメントは生成AI(Claude Sonnet 4.5)によって2026年1月6日に生成されました。*

## 課題概要

`ScopedProxyBeanRegistrationAotProcessor`が実際には呼び出されず、スコープ付きプロキシBeanのAOT処理が機能しないバグの修正です。

**背景説明**:
- **スコープ付きプロキシ**: リクエストスコープやセッションスコープのBeanを、シングルトンBeanから安全に参照するための仕組み
- **BeanRegistrationAotProcessor**: AOT時にBean登録をカスタマイズ処理するインターフェース
- **aot.factories**: AOTプロセッサーを自動検出するための設定ファイル（`META-INF/spring/aot.factories`）

**問題の詳細**:
スコープ付きプロキシを使用したアプリケーションをAOTコンパイルしようとすると、適切な処理が行われません：

```java
@Configuration
public class MyConfig {
    @Bean
    @Scope(value = "request", proxyMode = ScopedProxyMode.TARGET_CLASS)
    public RequestScopedService requestService() {
        return new RequestScopedService();
    }
    
    @Bean
    public SingletonService singletonService(RequestScopedService service) {
        // リクエストスコープのBeanをシングルトンから参照
        // プロキシが必要
        return new SingletonService(service);
    }
}
```

**発生するエラー**:
AOTコンパイル時に`ScopedProxyBeanRegistrationAotProcessor`が呼び出されず、スコープ付きプロキシのリフレクションヒントや特殊な登録コードが生成されません。

**原因の詳細**:
`META-INF/spring/aot.factories`ファイルに誤った設定：
```properties
# 誤った設定（存在しないクラスを指定）
org.springframework.beans.factory.aot.BeanRegistrationAotProcessor=\
  org.springframework.context.annotation.WrongClassName
```

## 原因

`aot.factories`設定ファイルで、`ScopedProxyBeanRegistrationAotProcessor`のエントリが以下のいずれかの問題を抱えていました：

1. **存在しないクラス名を指定**: リファクタリング後に正しいクラス名が更新されていない
2. **エントリの欠落**: そもそもエントリが記載されていない
3. **パッケージ名の誤り**: クラスの移動後にパッケージ名が古いまま

結果として、Spring FrameworkのAOT処理が`ScopedProxyBeanRegistrationAotProcessor`を検出・ロードできず、スコープ付きプロキシの処理がスキップされていました。

## 対応方針

以下のコミットで修正されました：

- [3aefa88](https://github.com/spring-projects/spring-framework/commit/3aefa88d3cb2f957f73a8fedd287f0f90c97df8e): 基本修正
- [176ea5e](https://github.com/spring-projects/spring-framework/commit/176ea5e9a7a04a81d76130c795d7597f0fc1de75): 追加調整

**実装内容**:

`META-INF/spring/aot.factories`ファイルの修正：

```properties
# 修正後の正しい設定
org.springframework.beans.factory.aot.BeanRegistrationAotProcessor=\
  org.springframework.context.annotation.ScopedProxyBeanRegistrationAotProcessor
```

**プロセッサーの機能**（正常に動作するようになった処理）：

```java
public class ScopedProxyBeanRegistrationAotProcessor 
        implements BeanRegistrationAotProcessor {
    
    @Override
    public BeanRegistrationAotContribution processAheadOfTime(
            RegisteredBean registeredBean) {
        
        // スコープ付きプロキシの検出
        if (isScopedProxy(registeredBean)) {
            return (context, code) -> {
                // 1. プロキシクラスのリフレクションヒント登録
                Class<?> proxyClass = registeredBean.getBeanClass();
                context.getRuntimeHints().reflection()
                    .registerType(proxyClass, 
                        MemberCategory.INVOKE_DECLARED_CONSTRUCTORS,
                        MemberCategory.INVOKE_DECLARED_METHODS);
                
                // 2. ターゲットクラスのヒント登録
                Class<?> targetClass = getTargetClass(proxyClass);
                context.getRuntimeHints().reflection()
                    .registerType(targetClass, ...);
                
                // 3. スコープ付きプロキシの特殊な登録コード生成
                code.addInstancePostProcessor(...);
            };
        }
        return null;
    }
}
```

**修正後の動作**:
```java
// AOT処理時
// 1. スコープ付きプロキシBeanが検出される
// 2. ScopedProxyBeanRegistrationAotProcessorが呼び出される
// 3. 必要なリフレクションヒントが登録される
// 4. プロキシ用の特殊なBean登録コードが生成される

// ネイティブイメージ実行時
// ✅ スコープ付きプロキシが正常に動作
```

**メリット**:
- スコープ付きプロキシがAOT/ネイティブイメージで動作
- リクエストスコープ/セッションスコープBeanの使用が可能に
- 適切なリフレクションヒント自動登録
- Spring Frameworkの標準的なスコープ機能が完全にサポート
