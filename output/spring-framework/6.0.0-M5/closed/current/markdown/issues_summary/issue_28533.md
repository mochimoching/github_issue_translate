*このドキュメントは生成AI(Claude Sonnet 4.5)によって2026年1月6日に生成されました。*

## 課題概要

HTTPインターフェースクライアント（`@HttpExchange`で定義されたクライアント）での例外処理を、単一の場所で一元的に行えるようにする機能強化です。

**背景説明**:
- **HTTPインターフェースクライアント**: `@HttpExchange`アノテーションを使ってHTTPクライアントを宣言的に定義する仕組み
- **WebClientException**: WebClientでエラーが発生した際にスローされる例外
- **ステータスハンドラー**: HTTPレスポンスのステータスコードに応じた処理を定義する仕組み

**問題の詳細**:
現状では、HTTPクライアントでの例外を一元的に処理する良い方法がありません：

```java
@HttpExchange("https://api.example.com")
public interface ApiClient {
    @GetExchange("/users/{id}")
    User getUser(@PathVariable Long id);  // エラー時にWebClientExceptionがスロー
    
    @PostExchange("/users")
    User createUser(@RequestBody UserDto dto);  // エラー時にWebClientExceptionがスロー
}

// 使用側: 各呼び出しで例外処理が必要
try {
    User user = apiClient.getUser(123L);
} catch (WebClientException e) {
    // カスタム例外に変換
    throw new ApiException("Failed to fetch user", e);
}

try {
    User created = apiClient.createUser(dto);
} catch (WebClientException e) {
    // 同じ例外処理を繰り返す
    throw new ApiException("Failed to create user", e);
}
```

**要望**:
- すべてのAPIメソッドで共通の例外処理を適用したい
- `WebClientException`をアプリケーション固有の例外に変換したい
- 特定のHTTPステータスコードに対する共通処理を定義したい
- リクエストごとではなく、クライアント全体に適用したい

`WebClient`にはステータスハンドラーがありますが、リクエストごとに設定する必要があり、ビルダーで共通設定として公開されていません。

## 原因

`HttpServiceProxyFactory`の設計が、例外処理のカスタマイズポイントを提供していませんでした。

`WebClient`のステータスハンドラーは存在しますが：
- リクエストごとに設定が必要
- `WebClient.Builder`では公開されていない
- HTTPインターフェース全体に適用する手段がない

## 対応方針

以下のコミットで実装されました：

- [a04e805](https://github.com/spring-projects/spring-framework/commit/a04e805d2709122e2bb43a35f71d6c4d1f04ab41)
- [24c4614](https://github.com/spring-projects/spring-framework/commit/24c46142c63ff0375e83374766903ac87c86d85d)

**実装内容**:

`HttpServiceProxyFactory`に例外処理設定を追加：

```java
// ファクトリー設定時に例外ハンドラーを登録
HttpServiceProxyFactory factory = HttpServiceProxyFactory.builder()
    .webClient(webClient)
    .errorHandler((exchange, exception) -> {
        // すべてのリクエストで共通の例外処理
        if (exception instanceof WebClientResponseException) {
            WebClientResponseException ex = (WebClientResponseException) exception;
            // ステータスコードに応じた処理
            if (ex.getStatusCode().is4xxClientError()) {
                throw new ApiClientException("Client error", ex);
            } else if (ex.getStatusCode().is5xxServerError()) {
                throw new ApiServerException("Server error", ex);
            }
        }
        throw new ApiException("Unknown error", exception);
    })
    .build();

ApiClient client = factory.createClient(ApiClient.class);

// 使用側: 例外処理が簡潔に
try {
    User user = client.getUser(123L);  // カスタム例外が自動的にスロー
} catch (ApiClientException e) {
    // アプリケーション固有の例外で処理
}
```

**主な機能**:
1. **クライアント全体での例外ハンドラー**: すべてのメソッド呼び出しに適用
2. **ステータスコード別の処理**: 4xx、5xxなどで異なる処理
3. **例外の変換**: `WebClientException`をアプリケーション固有の例外に変換
4. **一元化された例外処理**: DRY原則に従った設計

**使用例（詳細）**:
```java
@Configuration
public class ApiClientConfig {
    @Bean
    public HttpServiceProxyFactory httpServiceProxyFactory(WebClient.Builder builder) {
        return HttpServiceProxyFactory.builder()
            .webClient(builder.build())
            .errorHandler((exchange, exception) -> {
                // ログ記録
                log.error("API call failed: {}", exchange.getUri(), exception);
                
                // ステータスコード別処理
                if (exception instanceof WebClientResponseException) {
                    HttpStatus status = ((WebClientResponseException) exception).getStatusCode();
                    if (status == HttpStatus.NOT_FOUND) {
                        throw new ResourceNotFoundException(exception);
                    } else if (status == HttpStatus.UNAUTHORIZED) {
                        throw new AuthenticationException(exception);
                    }
                }
                
                // デフォルト処理
                throw new ApiException("API request failed", exception);
            })
            .build();
    }
}
```

**メリット**:
- 例外処理の一元化
- コードの重複削減
- アプリケーション固有の例外体系との統合が容易
- テストが容易に（モックエラーハンドラーの注入）
