# Bean定義名とエイリアスの間でオーバーライド(および非オーバーライドの強制)が一貫していない

**Issue番号**: #27866

**状態**: closed | **作成者**: levitin | **作成日**: 2021-12-29

**ラベル**: type: bug, in: core

**URL**: https://github.com/spring-projects/spring-framework/issues/27866

**関連リンク**:
- Commits:
  - [6b1c2dc](https://github.com/spring-projects/spring-framework/commit/6b1c2dc944e9541720d8fd7de3ce3c54ca03d5c2)

## 内容

2つのBeanを登録しようとしたときに(最初のBeanのエイリアスの1つが、2番目のBeanのメソッド名(つまり将来のID)に対応している場合)、2番目のBeanの作成は無視されます。コンテキストは例外なしで起動します。

```java
@Configuration
public class MyConfiguration {

    @Bean({"name1", "name2"})
    public MyInterface myBean() {
        return new MyFirstBean();
    }

    @Bean
    public MyInterface name2() {
        return new MySecondBean();
    }
}
```

次の例の`MyMap`には実際には1つのBeanのみが含まれます:`name1 -> MyFirstBean`

```java
    @Autowired
    Map<String, MyInterface> myMap;
```

これがバグなのか機能なのか分かりません。私の意見では、このケースでは[NoUniqueBeanDefinitionException](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/beans/factory/NoUniqueBeanDefinitionException.html)がスローされるべきだと思います。

どう思われますか?

## コメント

### コメント 1 by snicoll

**作成日**: 2021-12-29

場合によります。`myBean`が`name1`と`name2`を要求していることを考えると、`MySecondBean`が作成されないのは論理的に思えます。どこかで優先順位を付ける必要があります。逆にした場合、`MyFirstBean`が`name2`のエイリアスを宣言しているにもかかわらず使用されないと同様に主張できるでしょう。

とはいえ、Spring BootではデフォルトでBean定義のオーバーライドを防いでいるため、これが失敗すると予想していました。しかし失敗せず、それはもう少し驚きでした。チームからのさらなるフィードバックを得るためにフラグを立てます。

### コメント 2 by levitin

**作成日**: 2021-12-29

> 逆にした場合、MyFirstBeanがname2のエイリアスを宣言しているにもかかわらず使用されないと同様に主張できるでしょう。

はい、別の方向でも不快な驚きを引き起こすでしょう。しかし、あるBeanに「無害な」エイリアスを与えることで、名前が一致した場合に突然別の既存のBeanが除外されるというのはさらに悪いです。そのような副作用は本当に危険だと思います。おそらくセキュリティ問題にさえなり得ます。

私の意見では、上記のようなケースでは、コンテキストがまったく起動しないほうがはるかに安全だと思います。

すべてのBean名とすべてのエイリアスを一意なものとして扱わない理由はありますか?

### コメント 3 by jhoeller

**作成日**: 2022-01-18

Bean定義名とエイリアスの間のオーバーライドチェックには、確かに2つの不一致があります。`allowBeanDefinitionOverriding=false`(Bootのデフォルトのように)のときに既存のエイリアスをオーバーライドする新しいBean定義が防止されないだけでなく、`allowBeanDefinitionOverriding=true`のときに、ファクトリが新しいBean定義を黙って登録するものの、同名のエイリアスを削除しません。

言い換えれば、Bean定義名とエイリアス間のBean定義のオーバーライドは機能ですが、後の定義は既存の定義を一貫してオーバーライドする必要があります。したがって、このシナリオでは、`name2`メソッドは既存の`name2`エイリアスをオーバーライドすべきです。そして、オーバーライドが無効化されている場合、既存のエイリアスに対するそのようなオーバーライドの試みに遭遇したときには、一貫して例外をスローすべきです。

6.0 M3でこれを修正します。
