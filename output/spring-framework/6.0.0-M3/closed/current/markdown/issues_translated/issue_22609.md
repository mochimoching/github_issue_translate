# デフォルトで@Beanメソッドのオーバーロードを防止する(意図しないオーバーロードと条件の不一致を回避)

**Issue番号**: #22609

**状態**: closed | **作成者**: rfelgent | **作成日**: 2019-03-17

**ラベル**: in: core, type: enhancement

**URL**: https://github.com/spring-projects/spring-framework/issues/22609

## 内容

こんにちは。

Java Configで同じIDだが異なるプロパティを持つBeanを設定する際に、エラーメッセージがあまり役に立たなかったため、数時間を費やしてしまいました。

問題のBeanは、宣言的な`@DependsOn`設定によって必要とされるため、作成される必要があります。

エラー内容:

```
A component required a bean named 'postgresqlContainer' that could not be found.

	- Bean method 'postgresqlContainer' in 'PersistenceConfig.DbServersConfig' not loaded because @ConditionalOnProperty (app.persistence.servers.postgresql.enabled=true) found different value in property 'enabled'

	- Bean method 'postgresqlContainer' in 'PersistenceConfig.DbServersConfig' not loaded because @ConditionalOnProperty (app.persistence.servers.postgresql.enabled=true) found different value in property 'enabled'

```

この設定は失敗します:

```java
@Configuration
public class PersistenceConfig {

  @Configuration
  public class DbServersConfig {

    @Bean(value = "postgresqlContainer", initMethod = "start", destroyMethod = "stop")
    @ConditionalOnProperty(prefix = "app.persistence.servers.postgresql", name = "enabled", havingValue = "true")
    public PostgreSQLContainer postgresqlContainer(TCPostgresqlProperties postgresqlProperties) {
        Instance retVal = <do_your_logic>
        return retVal;
    }

    @Bean("postgresqlContainer")
    @ConditionalOnProperty(prefix = "app.persistence.servers.postgresql", name = "enabled", havingValue = "false", matchIfMissing = true)
    public PostgreSQLContainer postgresqlContainer() {
      return null;
    }
  }
}
```

この設定は動作します:

```java
@Configuration
public class PersistenceConfig {

  @Configuration
  public class DbServersConfig {

    @Bean(value = "postgresqlContainer", initMethod = "start", destroyMethod = "stop")
    @ConditionalOnProperty(prefix = "app.persistence.servers.postgresql", name = "enabled", havingValue = "true")
    public PostgreSQLContainer  postgresqlContainer(TCPostgresqlProperties postgresqlProperties) {
        Instance retVal = <do_your_logic>
        return retVal;
    }

    @Bean("postgresqlContainer")
    @ConditionalOnProperty(prefix = "app.persistence.servers.postgresql", name = "enabled", havingValue = "false", matchIfMissing = true)
    public PostgreSQLContainer postgresqlContainer2() {
      return null;
    }
  }
}
```

両方のメソッドに異なる名前(`postgresqlContainer`と`postgresqlContainer2`)を付けると、期待通りに動作しますが、そうしないとエラーが発生します。

これは意図された動作なのでしょうか?

このシナリオがバグを示している可能性もあるのか分かりません。この問題が`@ConditionalOnProperty`にのみ発生するのか、`@ConditionalOnExpression`のような他の条件でも発生するのかも分かりません。

よろしくお願いします。

## コメント

### コメント 1 by mbhave

**作成日**: 2019-03-18

@rfelgent この動作を再現できました。これはSpring Frameworkの[この部分](https://github.com/spring-projects/spring-framework/blob/master/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassBeanDefinitionReader.java#L188)が原因で発生しているようです。このチェックは、Bean定義が処理される順序に依存するため、予測不可能な動作を引き起こす可能性があります。上記の例では、2番目のBeanに対応するBean定義が最初に処理されると、`configClass.skippedBeanMethods.contains(methodName)`が`false`を返すため、読み込まれてしまいます。

Spring Bootでできることは何もないと思います。残りのチームがFrameworkで修正できると考えるなら、Spring Frameworkの課題トラッカーに移すことができます。

### コメント 2 by wilkinsona

**作成日**: 2019-03-19

Frameworkの動作は、[このロジック](https://github.com/spring-projects/spring-framework/blob/0fc0849c0a13eb504cd2f308d3824148f8f36806/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java#L394-L422)により予測可能であるはずです。

メソッドがすでにスキップされているかどうかを判断する際に、メソッド名よりも明確なものを使用する機能強化を検討するため、これをFrameworkに移す価値があると思います。@rfelgentさんがすでに指摘されているように、簡単な回避策は、`@Bean`メソッドのオーバーロードを避け、明確なメソッド名を使用することです。

### コメント 3 by sbrannen

**作成日**: 2019-03-19

@mbhaveさんと@wilkinsonaさん、調査ありがとうございます!

問題のアルゴリズムは、オーバーロードされたメソッドを考慮し、各メソッドの名前と仮引数リストに基づいてスキップされたメソッドを追跡すべきだと私も同意します。

残りのチームも同意するか見てみましょう。

### コメント 4 by jhoeller

**作成日**: 2019-03-19

現在の動作は、多かれ少なかれ設計によるものです。Bean名ごとに1つのBean定義しか存在しないため、概念的には、すべての関連するメタデータを名前ごとに1つの定義にマージしています。オーバーロードされた`@Bean`メソッドは、特定のBeanクラス上のオーバーロードされたコンストラクタと実質的に同じで、やはり1つのBean定義のみを構成します。そして、条件処理については、すべてのオーバーロードされたメソッド上のすべての条件が、実質的に同じ単一のBeanに適用されます。条件をBeanメソッドごとに分離することは簡単ではありません。なぜなら、Bean定義ではなく、オーバーロードされたファクトリメソッドの選択に条件を適用する必要があるためです。

一般的な推奨事項は、実際にオーバーロードではなく、明確なBean名/メソッド名を使用することです。そして、オーバーロードの場合は、すべてのオーバーロードされたメソッドに同じアノテーションを宣言することです。なぜなら、これが実行時の実際のセマンティクスに最も近いからです。これは本当に明白ではないため、少なくともこれを適切にドキュメント化する必要があります...そして、同じBean定義に対するオーバーロードされたメソッド間で条件の不一致がある場合には、統一された条件または明確なBean名を提案する例外を発生させることもできるかもしれません。
