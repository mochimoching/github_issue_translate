# Inconsistent overriding (and enforcement of non-overriding) between bean definition names and aliases

**Issue番号**: #27866

**状態**: closed | **作成者**: levitin | **作成日**: 2021-12-29

**ラベル**: type: bug, in: core

**URL**: https://github.com/spring-projects/spring-framework/issues/27866

**関連リンク**:
- Commits:
  - [6b1c2dc](https://github.com/spring-projects/spring-framework/commit/6b1c2dc944e9541720d8fd7de3ce3c54ca03d5c2)

## 内容

When I try to register two beans (one of aliases of the first bean corresponds to method name (= future id) of the second bean, the creation of second bean is ignored. The context starts without any exception. 

```java
@Configuration
public class MyConfiguration {

    @Bean({"name1", "name2"})
    public MyInterface myBean() {
        return new MyFirstBean();
    }

    @Bean
    public MyInterface name2() {
        return new MySecondBean();
    }
}
```

`MyMap` in the following example contains only one bean, actually: `name1 -> MyFirstBean`

```java
    @Autowired
    Map<String, MyInterface> myMap;
```

I'm not sure if it is a bug or a feature. In my opinion [NoUniqueBeanDefinitionException](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/beans/factory/NoUniqueBeanDefinitionException.html) should be thrown in this case.

What do you think?

## コメント

### コメント 1 by snicoll

**作成日**: 2021-12-29

It depends. Given that `myBean` claims `name1` and `name2`, it sounds logical that `MySecondBean` isn't created. We need to put a priority somewhere. If we did the reverse, you could equally claim that `MyFirstBean` isn't used despite it declaring an alias for `name2`.

Having said that, I was expecting this to fail with Spring Boot as we prevent bean overriding by default. It did not and that felt a little bit more surprising. Flagging to get more feedback from the team.


### コメント 2 by levitin

**作成日**: 2021-12-29

> If we did the reverse, you could equally claim that MyFirstBean isn't used despite it declaring an alias for name2

Yes, another direction would also cause an unpleasant surprise. But it is even worse, if giving any bean a "harmless" alias would suddenly exclude another existing bean in case of name matching. I think, such side effect could be really dangerous, perhaps it can be even a security issue. 

In my opinion, in such case as described above, it would be much more safer, if the context would not even start at all. 

Is there any reason not to treat every bean name and every alias as unique?


### コメント 3 by jhoeller

**作成日**: 2022-01-18

There are indeed two inconsistencies in our overriding checks between bean definition names and aliases: Not only is a new bean definition overriding an existing alias not prevented when allowBeanDefinitionOverriding=false (like in Boot by default), the factory also silently registers a new bean definition but does not remove a same-named alias when allowBeanDefinitionOverriding=true.

In other words, bean definition overriding between bean definition names and aliases is a feature, but a later definition should consistently override an existing definition - so in our scenario here, the `name2` method should override the existing `name2` alias. And with overriding deactivated, it should consistently throw an exception when encountering such an attempted override for an existing alias.

I'll revise this for 6.0 M3.

